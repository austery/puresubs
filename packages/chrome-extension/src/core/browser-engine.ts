/**
 * Browser-specific implementation of PureSubs core engine
 * This version uses browser fetch API and runs in Chrome extension context
 */

export interface SubtitleTrack {
  /** Language code (e.g., 'en', 'zh-Hans') */
  language: string;
  /** Human readable language name */
  name: string;
  /** Whether this is auto-generated or manual */
  isAutoGenerated: boolean;
  /** URL to the subtitle XML file */
  baseUrl: string;
}

export interface SubtitleEntry {
  /** Start time in seconds */
  start: number;
  /** End time in seconds */
  end: number;
  /** Subtitle text content */
  text: string;
}

export interface YouTubeVideoData {
  /** Video title */
  title: string;
  /** Video description */
  description: string;
  /** Available subtitle tracks */
  availableSubtitles: SubtitleTrack[];
  /** Extracted subtitles in different formats */
  subtitles?: {
    /** SRT format with timestamps */
    srt: string;
    /** Plain text format */
    txt: string;
    /** Raw subtitle entries */
    entries: SubtitleEntry[];
  };
}

export interface ExtractOptions {
  /** Preferred language codes in order of preference */
  preferredLanguages?: string[];
  /** Whether to include auto-generated subtitles */
  includeAutoGenerated?: boolean;
  /** Whether to extract subtitle content (default: false) */
  extractSubtitles?: boolean;
  /** Target language for subtitle extraction */
  subtitleLanguage?: string;
}

/**
 * Extract ytInitialPlayerResponse from current page
 * This works in Chrome extension content script context
 */
export function extractPlayerResponseFromPage(): any {
  try {
    console.log('[PureSubs] Starting to extract ytInitialPlayerResponse from page');
    const scripts = document.querySelectorAll('script');
    console.log(`[PureSubs] Found ${scripts.length} script tags`);
    
    for (let i = 0; i < scripts.length; i++) {
      const script = scripts[i];
      const content = script.innerHTML;
      
      // Try different patterns for ytInitialPlayerResponse
      const patterns = [
        // Most common: var ytInitialPlayerResponse = {...};
        /var ytInitialPlayerResponse\s*=\s*(\{.+?\});/s,
        // Alternative: ytInitialPlayerResponse = {...}
        /ytInitialPlayerResponse\s*=\s*(\{.+?\});/s,
        // In JSON context
        /"ytInitialPlayerResponse":\s*(\{.+?\})/s,
        // Window context
        /window\["ytInitialPlayerResponse"\]\s*=\s*(\{.+?\});/s,
        // Direct assignment with brackets
        /ytInitialPlayerResponse["\s]*[:=]\s*(\{.+?\})/s
      ];
      
      for (const pattern of patterns) {
        const match = content.match(pattern);
        if (match) {
          console.log('[PureSubs] Found ytInitialPlayerResponse with pattern:', pattern);
          const playerResponse = JSON.parse(match[1]);
          console.log('[PureSubs] Parsed playerResponse:', playerResponse);
          return playerResponse;
        }
      }
    }
    
    console.error('[PureSubs] Could not find ytInitialPlayerResponse in any script tag');
    throw new Error('Could not find ytInitialPlayerResponse in page');
  } catch (error) {
    console.error('[PureSubs] Error parsing ytInitialPlayerResponse:', error);
    throw new Error(`Failed to parse ytInitialPlayerResponse: ${error}`);
  }
}

/**
 * Extract video metadata from player response
 */
export function extractVideoMetadata(playerResponse: any): {
  title: string;
  description: string;
} {
  try {
    const videoDetails = playerResponse.videoDetails;
    
    if (!videoDetails) {
      throw new Error('No videoDetails found in playerResponse');
    }
    
    return {
      title: videoDetails.title || 'Untitled',
      description: videoDetails.shortDescription || ''
    };
  } catch (error) {
    throw new Error(`Failed to extract video metadata: ${error}`);
  }
}

/**
 * Extract subtitle tracks from player response
 */
export function extractSubtitleTracks(playerResponse: any): SubtitleTrack[] {
  try {
    console.log('[PureSubs] Extracting subtitle tracks from playerResponse');
    console.log('[PureSubs] PlayerResponse captions:', playerResponse?.captions);
    
    const captionsArray = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
    console.log('[PureSubs] Found captionTracks:', captionsArray);
    
    if (!captionsArray || !Array.isArray(captionsArray)) {
      console.warn('[PureSubs] No caption tracks found or not array');
      return [];
    }
    
    const tracks = captionsArray.map((caption: any): SubtitleTrack => {
      const track = {
        language: caption.languageCode || 'unknown',
        name: caption.name?.simpleText || caption.name?.runs?.[0]?.text || 'Unknown',
        isAutoGenerated: caption.kind === 'asr',
        baseUrl: caption.baseUrl
      };
      console.log('[PureSubs] Processed track:', track);
      return track;
    });
    
    console.log(`[PureSubs] Extracted ${tracks.length} subtitle tracks:`, tracks);
    return tracks;
  } catch (error) {
    console.error('[PureSubs] Failed to extract subtitle tracks:', error);
    return [];
  }
}

/**
 * Fetch subtitle XML content from URL using browser fetch
 */
export async function fetchSubtitleXML(subtitleUrl: string): Promise<string> {
  try {
    console.log('[PureSubs] Fetching subtitle XML from:', subtitleUrl);
    
    // First, try the original URL as-is
    const response = await fetch(subtitleUrl);
    console.log('[PureSubs] Fetch response status:', response.status, response.statusText);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const xmlContent = await response.text();
    console.log('[PureSubs] Fetched XML content length:', xmlContent.length);
    console.log('[PureSubs] XML content preview:', xmlContent.substring(0, 500));
    
    // If we get empty content, it might be due to the 'caps=asr' parameter
    // Try constructing a new URL without problematic parameters but keeping the signature valid
    if (xmlContent.length === 0) {
      console.log('[PureSubs] Empty response with original URL, trying alternative approach...');
      
      // Parse the URL to extract key parameters
      const url = new URL(subtitleUrl);
      const videoId = url.searchParams.get('v');
      const lang = url.searchParams.get('lang');
      
      if (videoId && lang) {
        // Try a simplified URL format that might work
        const simpleUrl = `https://www.youtube.com/api/timedtext?v=${videoId}&lang=${lang}&fmt=srv3`;
        console.log('[PureSubs] Trying simplified URL:', simpleUrl);
        
        try {
          const simpleResponse = await fetch(simpleUrl);
          if (simpleResponse.ok) {
            const simpleContent = await simpleResponse.text();
            console.log('[PureSubs] Simplified URL response length:', simpleContent.length);
            if (simpleContent.length > 0) {
              return simpleContent;
            }
          }
        } catch (simpleError) {
          console.log('[PureSubs] Simplified URL failed:', simpleError);
        }
        
        // Try without fmt parameter
        const basicUrl = `https://www.youtube.com/api/timedtext?v=${videoId}&lang=${lang}`;
        console.log('[PureSubs] Trying basic URL:', basicUrl);
        
        try {
          const basicResponse = await fetch(basicUrl);
          if (basicResponse.ok) {
            const basicContent = await basicResponse.text();
            console.log('[PureSubs] Basic URL response length:', basicContent.length);
            if (basicContent.length > 0) {
              return basicContent;
            }
          }
        } catch (basicError) {
          console.log('[PureSubs] Basic URL failed:', basicError);
        }
      }
    }
    
    return xmlContent;
  } catch (error) {
    console.error('[PureSubs] Failed to fetch subtitle XML:', error);
    throw new Error(`Failed to fetch subtitle XML: ${error}`);
  }
}

/**
 * Parse subtitle XML content into structured data
 */
export function parseSubtitleXML(xmlContent: string): SubtitleEntry[] {
  try {
    console.log('[PureSubs] Parsing subtitle XML, content length:', xmlContent.length);
    const entries: SubtitleEntry[] = [];
    
    // Multiple regex patterns for different YouTube subtitle XML formats
    const textPatterns = [
      // Standard format: <text start="12.34" dur="2.5">Hello world</text>
      /<text start="([^"]+)"(?:\s+dur="([^"]+)")?>([^<]*)<\/text>/g,
      // Self-closing format with more attributes
      /<text[^>]+start="([^"]+)"[^>]*(?:dur="([^"]+)")?[^>]*>([^<]*)<\/text>/g,
      // Alternative format with different attributes order
      /<text[^>]*start="([^"]+)"[^>]*>([^<]*)<\/text>/g,
      // srv3 format: <p t="12340" d="2500">Hello world</p>
      /<p t="([^"]+)"(?:\s+d="([^"]+)")?>([^<]*)<\/p>/g,
      // srv1 format with different structure
      /<text[^>]*t="([^"]+)"[^>]*(?:d="([^"]+)")?[^>]*>([^<]*)<\/text>/g,
      // More flexible pattern for any timing attribute
      /<(?:text|p)[^>]*(?:start|t)="([^"]+)"[^>]*(?:(?:dur|d)="([^"]+)")?[^>]*>([^<]*)<\/(?:text|p)>/g
    ];
    
    let matchCount = 0;
    
    // Try each pattern until we find matches
    for (const textRegex of textPatterns) {
      console.log('[PureSubs] Trying pattern:', textRegex);
      textRegex.lastIndex = 0; // Reset regex state
      
      let match;
      while ((match = textRegex.exec(xmlContent)) !== null) {
        matchCount++;
        let start = parseFloat(match[1]);
        
        // Handle different match group arrangements
        let duration = 0;
        let rawText = '';
        
        if (match.length === 4) {
          // Pattern with dur group
          duration = match[2] ? parseFloat(match[2]) : 0;
          rawText = match[3];
        } else if (match.length === 3) {
          // Pattern without dur group  
          rawText = match[2];
        }
        
        // Convert milliseconds to seconds if needed (srv3 format uses milliseconds)
        if (start > 10000) {
          // Likely milliseconds, convert to seconds
          start = start / 1000;
          if (duration > 0) {
            duration = duration / 1000;
          }
        }
        
        const text = cleanSubtitleText(rawText);
        
        if (matchCount <= 5) {
          console.log(`[PureSubs] Match ${matchCount}:`, { start, duration, rawText, cleanedText: text });
        }
        
        if (text.trim()) {
          entries.push({
            start: start,
            end: start + (duration || 2), // Default 2-second duration if not specified
            text: text
          });
        }
      }
      
      // If we found matches with this pattern, break
      if (matchCount > 0) {
        console.log(`[PureSubs] Successfully used pattern: ${textRegex}, found ${matchCount} matches`);
        break;
      }
    }
    
    console.log(`[PureSubs] Found ${matchCount} text matches, ${entries.length} valid entries`);
    
    // Sort entries by start time
    const sortedEntries = entries.sort((a, b) => a.start - b.start);
    console.log('[PureSubs] First 3 parsed entries:', sortedEntries.slice(0, 3));
    return sortedEntries;
  } catch (error) {
    console.error('[PureSubs] Failed to parse subtitle XML:', error);
    throw new Error(`Failed to parse subtitle XML: ${error}`);
  }
}

/**
 * Clean subtitle text by removing HTML tags and fixing encoding
 */
export function cleanSubtitleText(text: string): string {
  if (!text) return '';
  
  return text
    // Remove HTML tags
    .replace(/<[^>]*>/g, '')
    // Decode HTML entities
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    // Clean up extra whitespace
    .replace(/\s+/g, ' ')
    .trim();
}

/**
 * Convert subtitle entries to SRT format
 */
export function convertToSRT(entries: SubtitleEntry[]): string {
  console.log(`[PureSubs] Converting ${entries?.length || 0} entries to SRT format`);
  
  if (!entries || entries.length === 0) {
    console.warn('[PureSubs] No entries to convert to SRT');
    return '';
  }
  
  const srtContent = entries
    .map((entry, index) => {
      const startTime = formatSRTTimestamp(entry.start);
      const endTime = formatSRTTimestamp(entry.end);
      
      const srtBlock = [
        (index + 1).toString(),
        `${startTime} --> ${endTime}`,
        entry.text,
        ''
      ].join('\n');
      
      if (index < 3) {
        console.log(`[PureSubs] SRT block ${index + 1}:`, srtBlock);
      }
      
      return srtBlock;
    })
    .join('\n');
    
  console.log(`[PureSubs] Generated SRT content length: ${srtContent.length}`);
  return srtContent;
}

/**
 * Convert subtitle entries to plain text format
 */
export function convertToTXT(entries: SubtitleEntry[], separator: string = '\n'): string {
  console.log(`[PureSubs] Converting ${entries?.length || 0} entries to TXT format`);
  
  if (!entries || entries.length === 0) {
    console.warn('[PureSubs] No entries to convert to TXT');
    return '';
  }
  
  const txtContent = entries.map(entry => entry.text.trim()).join(separator);
  console.log(`[PureSubs] Generated TXT content length: ${txtContent.length}`);
  return txtContent;
}

/**
 * Format time in seconds to SRT timestamp format (HH:MM:SS,mmm)
 */
export function formatSRTTimestamp(seconds: number): string {
  // Round to 3 decimal places to avoid floating point precision issues
  const roundedSeconds = Math.round(seconds * 1000) / 1000;
  
  const hours = Math.floor(roundedSeconds / 3600);
  const minutes = Math.floor((roundedSeconds % 3600) / 60);
  const secs = Math.floor(roundedSeconds % 60);
  const milliseconds = Math.round((roundedSeconds % 1) * 1000);
  
  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${milliseconds.toString().padStart(3, '0')}`;
}

/**
 * Select the best subtitle based on smart priority logic
 * Priority: 中文 (zh-Hans, zh-CN, zh) -> 英文 (en) -> 其他语言
 */
export function selectBestSubtitle(availableSubtitles: SubtitleTrack[]): SubtitleTrack | null {
  if (!availableSubtitles || availableSubtitles.length === 0) {
    return null;
  }

  // 优先级定义：中文变体
  const chineseLanguages = ['zh-Hans', 'zh-CN', 'zh', 'zh-TW', 'zh-HK'];
  const englishLanguages = ['en', 'en-US', 'en-GB'];

  // Step 1: 查找中文字幕 (优先人工字幕)
  for (const lang of chineseLanguages) {
    // 首先查找人工中文字幕
    const manualChinese = availableSubtitles.find(sub => 
      sub.language === lang && !sub.isAutoGenerated
    );
    if (manualChinese) {
      console.log('[PureSubs] Selected manual Chinese subtitles:', lang);
      return manualChinese;
    }
  }

  // Step 2: 查找自动生成的中文字幕
  for (const lang of chineseLanguages) {
    const autoChinese = availableSubtitles.find(sub => 
      sub.language === lang && sub.isAutoGenerated
    );
    if (autoChinese) {
      console.log('[PureSubs] Selected auto-generated Chinese subtitles:', lang);
      return autoChinese;
    }
  }

  // Step 3: 查找英文字幕 (优先人工字幕)
  for (const lang of englishLanguages) {
    const manualEnglish = availableSubtitles.find(sub => 
      sub.language === lang && !sub.isAutoGenerated
    );
    if (manualEnglish) {
      console.log('[PureSubs] Selected manual English subtitles:', lang);
      return manualEnglish;
    }
  }

  // Step 4: 查找自动生成的英文字幕
  for (const lang of englishLanguages) {
    const autoEnglish = availableSubtitles.find(sub => 
      sub.language === lang && sub.isAutoGenerated
    );
    if (autoEnglish) {
      console.log('[PureSubs] Selected auto-generated English subtitles:', lang);
      return autoEnglish;
    }
  }

  // Step 5: 如果没有中文和英文，返回第一个可用的字幕
  const fallback = availableSubtitles[0];
  console.log('[PureSubs] Using fallback subtitle:', fallback.language);
  return fallback;
}

/**
 * Main function to extract YouTube data from current page
 * This works in Chrome extension context without external dependencies
 */
export async function getYouTubeDataFromPage(options: ExtractOptions = {}): Promise<YouTubeVideoData> {
  try {
    // Step 1: Extract ytInitialPlayerResponse from current page
    const playerResponse = extractPlayerResponseFromPage();
    
    // Step 2: Extract video metadata
    const metadata = extractVideoMetadata(playerResponse);
    
    // Step 3: Extract available subtitle tracks
    const availableSubtitles = extractSubtitleTracks(playerResponse);
    
    // Step 4: Extract subtitles if requested
    let subtitles;
    if (options.extractSubtitles && availableSubtitles.length > 0) {
      const selectedSubtitle = selectBestSubtitle(availableSubtitles);
      
      if (selectedSubtitle) {
        // Fetch and parse subtitle content
        const xmlContent = await fetchSubtitleXML(selectedSubtitle.baseUrl);
        const entries = parseSubtitleXML(xmlContent);
        
        subtitles = {
          srt: convertToSRT(entries),
          txt: convertToTXT(entries),
          entries: entries
        };
      }
    }
    
    return {
      title: metadata.title,
      description: metadata.description,
      availableSubtitles,
      subtitles
    };
  } catch (error) {
    throw new Error(`Failed to extract YouTube data: ${error}`);
  }
}