/**
 * Browser-specific implementation of PureSubs core engine
 * This version uses browser fetch API and runs in Chrome extension context
 */

export interface SubtitleTrack {
  /** Language code (e.g., 'en', 'zh-Hans') */
  language: string;
  /** Human readable language name */
  name: string;
  /** Whether this is auto-generated or manual */
  isAutoGenerated: boolean;
  /** URL to the subtitle XML file */
  baseUrl: string;
}

export interface SubtitleEntry {
  /** Start time in seconds */
  start: number;
  /** End time in seconds */
  end: number;
  /** Subtitle text content */
  text: string;
}

export interface YouTubeVideoData {
  /** Video title */
  title: string;
  /** Video description */
  description: string;
  /** Available subtitle tracks */
  availableSubtitles: SubtitleTrack[];
  /** Extracted subtitles in different formats */
  subtitles?: {
    /** SRT format with timestamps */
    srt: string;
    /** Plain text format */
    txt: string;
    /** Raw subtitle entries */
    entries: SubtitleEntry[];
  };
}

export interface ExtractOptions {
  /** Preferred language codes in order of preference */
  preferredLanguages?: string[];
  /** Whether to include auto-generated subtitles */
  includeAutoGenerated?: boolean;
  /** Whether to extract subtitle content (default: false) */
  extractSubtitles?: boolean;
  /** Target language for subtitle extraction */
  subtitleLanguage?: string;
}

/**
 * Extract ytInitialPlayerResponse from current page
 * This works in Chrome extension content script context
 */
export function extractPlayerResponseFromPage(): any {
  try {
    const scripts = document.querySelectorAll('script');
    
    for (let i = 0; i < scripts.length; i++) {
      const script = scripts[i];
      const content = script.innerHTML;
      
      // Try different patterns
      const patterns = [
        /var ytInitialPlayerResponse\s*=\s*(\{.+?\});/,
        /ytInitialPlayerResponse["\s]*[:=]\s*(\{.+?\}),?\s*["\}]/,
        /"ytInitialPlayerResponse":\s*(\{.+?\}),?"playerResponse"/
      ];
      
      for (const pattern of patterns) {
        const match = content.match(pattern);
        if (match) {
          return JSON.parse(match[1]);
        }
      }
    }
    
    throw new Error('Could not find ytInitialPlayerResponse in page');
  } catch (error) {
    throw new Error(`Failed to parse ytInitialPlayerResponse: ${error}`);
  }
}

/**
 * Extract video metadata from player response
 */
export function extractVideoMetadata(playerResponse: any): {
  title: string;
  description: string;
} {
  try {
    const videoDetails = playerResponse.videoDetails;
    
    if (!videoDetails) {
      throw new Error('No videoDetails found in playerResponse');
    }
    
    return {
      title: videoDetails.title || 'Untitled',
      description: videoDetails.shortDescription || ''
    };
  } catch (error) {
    throw new Error(`Failed to extract video metadata: ${error}`);
  }
}

/**
 * Extract subtitle tracks from player response
 */
export function extractSubtitleTracks(playerResponse: any): SubtitleTrack[] {
  try {
    const captionsArray = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
    
    if (!captionsArray || !Array.isArray(captionsArray)) {
      return [];
    }
    
    return captionsArray.map((caption: any): SubtitleTrack => ({
      language: caption.languageCode || 'unknown',
      name: caption.name?.simpleText || caption.name?.runs?.[0]?.text || 'Unknown',
      isAutoGenerated: caption.kind === 'asr',
      baseUrl: caption.baseUrl
    }));
  } catch (error) {
    console.warn('Failed to extract subtitle tracks:', error);
    return [];
  }
}

/**
 * Fetch subtitle XML content from URL using browser fetch
 */
export async function fetchSubtitleXML(subtitleUrl: string): Promise<string> {
  try {
    const response = await fetch(subtitleUrl);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return await response.text();
  } catch (error) {
    throw new Error(`Failed to fetch subtitle XML: ${error}`);
  }
}

/**
 * Parse subtitle XML content into structured data
 */
export function parseSubtitleXML(xmlContent: string): SubtitleEntry[] {
  try {
    const entries: SubtitleEntry[] = [];
    
    // Regex to match <text> tags with attributes and content
    const textRegex = /<text start="([^"]+)"(?:\s+dur="([^"]+)")?>([^<]*)<\/text>/g;
    
    let match;
    while ((match = textRegex.exec(xmlContent)) !== null) {
      const start = parseFloat(match[1]);
      const duration = match[2] ? parseFloat(match[2]) : 0;
      const text = cleanSubtitleText(match[3]);
      
      if (text.trim()) {
        entries.push({
          start: start,
          end: start + (duration || 0),
          text: text
        });
      }
    }
    
    // Sort entries by start time
    return entries.sort((a, b) => a.start - b.start);
  } catch (error) {
    throw new Error(`Failed to parse subtitle XML: ${error}`);
  }
}

/**
 * Clean subtitle text by removing HTML tags and fixing encoding
 */
export function cleanSubtitleText(text: string): string {
  if (!text) return '';
  
  return text
    // Remove HTML tags
    .replace(/<[^>]*>/g, '')
    // Decode HTML entities
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    // Clean up extra whitespace
    .replace(/\s+/g, ' ')
    .trim();
}

/**
 * Convert subtitle entries to SRT format
 */
export function convertToSRT(entries: SubtitleEntry[]): string {
  if (!entries || entries.length === 0) {
    return '';
  }
  
  return entries
    .map((entry, index) => {
      const startTime = formatSRTTimestamp(entry.start);
      const endTime = formatSRTTimestamp(entry.end);
      
      return [
        (index + 1).toString(),
        `${startTime} --> ${endTime}`,
        entry.text,
        ''
      ].join('\n');
    })
    .join('\n');
}

/**
 * Convert subtitle entries to plain text format
 */
export function convertToTXT(entries: SubtitleEntry[], separator: string = '\n'): string {
  if (!entries || entries.length === 0) {
    return '';
  }
  
  return entries.map(entry => entry.text.trim()).join(separator);
}

/**
 * Format time in seconds to SRT timestamp format (HH:MM:SS,mmm)
 */
export function formatSRTTimestamp(seconds: number): string {
  // Round to 3 decimal places to avoid floating point precision issues
  const roundedSeconds = Math.round(seconds * 1000) / 1000;
  
  const hours = Math.floor(roundedSeconds / 3600);
  const minutes = Math.floor((roundedSeconds % 3600) / 60);
  const secs = Math.floor(roundedSeconds % 60);
  const milliseconds = Math.round((roundedSeconds % 1) * 1000);
  
  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${milliseconds.toString().padStart(3, '0')}`;
}

/**
 * Select the best subtitle based on smart priority logic
 * Priority: 中文 (zh-Hans, zh-CN, zh) -> 英文 (en) -> 其他语言
 */
export function selectBestSubtitle(availableSubtitles: SubtitleTrack[]): SubtitleTrack | null {
  if (!availableSubtitles || availableSubtitles.length === 0) {
    return null;
  }

  // 优先级定义：中文变体
  const chineseLanguages = ['zh-Hans', 'zh-CN', 'zh', 'zh-TW', 'zh-HK'];
  const englishLanguages = ['en', 'en-US', 'en-GB'];

  // Step 1: 查找中文字幕 (优先人工字幕)
  for (const lang of chineseLanguages) {
    // 首先查找人工中文字幕
    const manualChinese = availableSubtitles.find(sub => 
      sub.language === lang && !sub.isAutoGenerated
    );
    if (manualChinese) {
      console.log('[PureSubs] Selected manual Chinese subtitles:', lang);
      return manualChinese;
    }
  }

  // Step 2: 查找自动生成的中文字幕
  for (const lang of chineseLanguages) {
    const autoChinese = availableSubtitles.find(sub => 
      sub.language === lang && sub.isAutoGenerated
    );
    if (autoChinese) {
      console.log('[PureSubs] Selected auto-generated Chinese subtitles:', lang);
      return autoChinese;
    }
  }

  // Step 3: 查找英文字幕 (优先人工字幕)
  for (const lang of englishLanguages) {
    const manualEnglish = availableSubtitles.find(sub => 
      sub.language === lang && !sub.isAutoGenerated
    );
    if (manualEnglish) {
      console.log('[PureSubs] Selected manual English subtitles:', lang);
      return manualEnglish;
    }
  }

  // Step 4: 查找自动生成的英文字幕
  for (const lang of englishLanguages) {
    const autoEnglish = availableSubtitles.find(sub => 
      sub.language === lang && sub.isAutoGenerated
    );
    if (autoEnglish) {
      console.log('[PureSubs] Selected auto-generated English subtitles:', lang);
      return autoEnglish;
    }
  }

  // Step 5: 如果没有中文和英文，返回第一个可用的字幕
  const fallback = availableSubtitles[0];
  console.log('[PureSubs] Using fallback subtitle:', fallback.language);
  return fallback;
}

/**
 * Main function to extract YouTube data from current page
 * This works in Chrome extension context without external dependencies
 */
export async function getYouTubeDataFromPage(options: ExtractOptions = {}): Promise<YouTubeVideoData> {
  try {
    // Step 1: Extract ytInitialPlayerResponse from current page
    const playerResponse = extractPlayerResponseFromPage();
    
    // Step 2: Extract video metadata
    const metadata = extractVideoMetadata(playerResponse);
    
    // Step 3: Extract available subtitle tracks
    const availableSubtitles = extractSubtitleTracks(playerResponse);
    
    // Step 4: Extract subtitles if requested
    let subtitles;
    if (options.extractSubtitles && availableSubtitles.length > 0) {
      const selectedSubtitle = selectBestSubtitle(availableSubtitles);
      
      if (selectedSubtitle) {
        // Fetch and parse subtitle content
        const xmlContent = await fetchSubtitleXML(selectedSubtitle.baseUrl);
        const entries = parseSubtitleXML(xmlContent);
        
        subtitles = {
          srt: convertToSRT(entries),
          txt: convertToTXT(entries),
          entries: entries
        };
      }
    }
    
    return {
      title: metadata.title,
      description: metadata.description,
      availableSubtitles,
      subtitles
    };
  } catch (error) {
    throw new Error(`Failed to extract YouTube data: ${error}`);
  }
}