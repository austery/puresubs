/**
 * Browser-specific implementation of PureSubs core engine
 * This version uses browser fetch API and runs in Chrome extension context
 */

import { 
  parseJSON3Subtitles
} from './subtitle-interceptor';

// 💡 间谍脚本数据接口
declare global {
  interface Window {
    PureSubsSpyData?: {
      [videoId: string]: {
        [language: string]: {
          content: string;
          format: string;
          timestamp: number;
        }
      }
    }
  }
}

/**
 * 获取间谍脚本拦截的字幕数据
 */
function getInterceptedSubtitleData(videoId: string, language: string): any {
  try {
    const spyData = window.PureSubsSpyData?.[videoId]?.[language];
    if (spyData && Date.now() - spyData.timestamp < 60000) { // 1分钟内的数据有效
      return spyData;
    }
    return null;
  } catch (error) {
    console.warn('[PureSubs] Error accessing spy data:', error);
    return null;
  }
}

export interface SubtitleTrack {
  /** Language code (e.g., 'en', 'zh-Hans') */
  language: string;
  /** Human readable language name */
  name: string;
  /** Whether this is auto-generated or manual */
  isAutoGenerated: boolean;
  /** URL to the subtitle XML file */
  baseUrl: string;
}

export interface SubtitleEntry {
  /** Start time in seconds */
  start: number;
  /** End time in seconds */
  end: number;
  /** Subtitle text content */
  text: string;
}

export interface YouTubeVideoData {
  /** Video title */
  title: string;
  /** Video description */
  description: string;
  /** Available subtitle tracks */
  availableSubtitles: SubtitleTrack[];
  /** Extracted subtitles in different formats */
  subtitles?: {
    /** SRT format with timestamps */
    srt: string;
    /** Plain text format */
    txt: string;
    /** Raw subtitle entries */
    entries: SubtitleEntry[];
  };
}

export interface ExtractOptions {
  /** Preferred language codes in order of preference */
  preferredLanguages?: string[];
  /** Whether to include auto-generated subtitles */
  includeAutoGenerated?: boolean;
  /** Whether to extract subtitle content (default: false) */
  extractSubtitles?: boolean;
  /** Target language for subtitle extraction */
  subtitleLanguage?: string;
}

/**
 * Extract ytInitialPlayerResponse from current page
 * This works in Chrome extension content script context
 */
export function extractPlayerResponseFromPage(): any {
  try {
    console.log('[PureSubs] Starting to extract ytInitialPlayerResponse from page');
    const scripts = document.querySelectorAll('script');
    console.log(`[PureSubs] Found ${scripts.length} script tags`);
    
    for (let i = 0; i < scripts.length; i++) {
      const script = scripts[i];
      const content = script.innerHTML;
      
      // Try different patterns for ytInitialPlayerResponse
      const patterns = [
        // Most common: var ytInitialPlayerResponse = {...};
        /var ytInitialPlayerResponse\s*=\s*(\{.+?\});/s,
        // Alternative: ytInitialPlayerResponse = {...}
        /ytInitialPlayerResponse\s*=\s*(\{.+?\});/s,
        // In JSON context
        /"ytInitialPlayerResponse":\s*(\{.+?\})/s,
        // Window context
        /window\["ytInitialPlayerResponse"\]\s*=\s*(\{.+?\});/s,
        // Direct assignment with brackets
        /ytInitialPlayerResponse["\s]*[:=]\s*(\{.+?\})/s
      ];
      
      for (const pattern of patterns) {
        const match = content.match(pattern);
        if (match) {
          console.log('[PureSubs] Found ytInitialPlayerResponse with pattern:', pattern);
          try {
            const playerResponse = JSON.parse(match[1]);
            console.log('[PureSubs] Parsed playerResponse:', playerResponse);
            return playerResponse;
          } catch {
            console.warn('[PureSubs] Failed to parse JSON, trying next match');
            continue;
          }
        }
      }
    }
    
    console.warn('[PureSubs] Could not find ytInitialPlayerResponse in any script tag');
    return {};
  } catch (error) {
    console.error('[PureSubs] Error extracting ytInitialPlayerResponse:', error);
    return {};
  }
}

/**
 * Extract video metadata from player response
 */
export function extractVideoMetadata(playerResponse: any): {
  title: string;
  description: string;
} {
  try {
    const videoDetails = playerResponse?.videoDetails;
    
    if (!videoDetails) {
      console.warn('[PureSubs] No videoDetails found in playerResponse');
      return {
        title: 'Untitled',
        description: ''
      };
    }

    return {
      title: videoDetails.title || 'Untitled',
      description: videoDetails.shortDescription || ''
    };
  } catch (error) {
    console.error('[PureSubs] Error extracting video metadata:', error);
    return {
      title: 'Untitled',
      description: ''
    };
  }
}/**
 * Extract subtitle tracks from player response
 */
export function extractSubtitleTracks(playerResponse: any): SubtitleTrack[] {
  try {
    console.log('[PureSubs] Extracting subtitle tracks from playerResponse');
    console.log('[PureSubs] PlayerResponse captions:', playerResponse?.captions);
    
    const captionsArray = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
    console.log('[PureSubs] Found captionTracks:', captionsArray);
    
    if (!captionsArray || !Array.isArray(captionsArray)) {
      console.warn('[PureSubs] No caption tracks found or not array');
      return [];
    }
    
    const tracks = captionsArray.map((caption: any): SubtitleTrack => {
      const track = {
        language: caption.languageCode || 'unknown',
        name: caption.name?.simpleText || caption.name?.runs?.[0]?.text || 'Unknown',
        isAutoGenerated: caption.kind === 'asr',
        baseUrl: caption.baseUrl
      };
      console.log('[PureSubs] Processed track:', track);
      return track;
    });
    
    console.log(`[PureSubs] Extracted ${tracks.length} subtitle tracks:`, tracks);
    return tracks;
  } catch (error) {
    console.error('[PureSubs] Failed to extract subtitle tracks:', error);
    return [];
  }
}

/**
 * Fetch subtitle XML content by delegating the request to the background script.
 * This is the correct way to handle cross-origin fetches with custom headers in MV3.
 */
export async function fetchSubtitleXML(subtitleUrl: string): Promise<string> {
  console.log('[PureSubs] Delegating fetch request to background script for URL:', subtitleUrl);

  // 定义一个函数，用于向后台发送消息并等待响应
  const fetchFromBackground = (url: string): Promise<string> => {
    return new Promise((resolve, reject) => {
      chrome.runtime.sendMessage(
        { type: 'FETCH_SUBTITLE_XML', payload: { url } },
        (response) => {
          if (chrome.runtime.lastError) {
            console.error('[PureSubs] Runtime error:', chrome.runtime.lastError.message);
            return reject(new Error(chrome.runtime.lastError.message));
          }
          if (response?.success) {
            console.log(`[PureSubs] Received content from background, length: ${response.content?.length || 0}`);
            console.log(`[PureSubs] Content preview:`, response.content?.substring(0, 500) || '');
            resolve(response.content || '');
          } else {
            const errorMessage = response?.error || 'Unknown error from background script';
            console.error('[PureSubs] Background script failed to fetch:', errorMessage);
            reject(new Error(errorMessage));
          }
        }
      );
    });
  };

  try {
    // 1. 首先尝试原始 URL
    const xmlContent = await fetchFromBackground(subtitleUrl);
    if (xmlContent && xmlContent.length > 0) {
      return xmlContent;
    }

    console.log('[PureSubs] Original URL returned empty content, this might be due to YouTube API changes');
    console.log('[PureSubs] Note: YouTube may have changed their subtitle API access policy');
    
    // 2. 如果原始 URL 返回空，可能是因为YouTube API的限制
    // 在实际情况下，这需要在浏览器环境中通过其他方式获取字幕
    console.warn('[PureSubs] YouTube subtitle API returned empty content. This is a known issue since 2023.');
    console.warn('[PureSubs] Possible solutions:');
    console.warn('[PureSubs] 1. Use browser extension context to access page data directly');
    console.warn('[PureSubs] 2. Extract subtitle data from page DOM if available');
    console.warn('[PureSubs] 3. Try alternative subtitle extraction methods');

    // 返回空字符串而不是抛出错误，让上层处理
    return '';

  } catch (error) {
    console.error('[PureSubs] Failed to fetch subtitle XML via background script:', error);
    throw new Error(`Failed to fetch subtitle XML: ${error}`);
  }
}

/**
 * Parse plain text into subtitle entries (fallback for DOM extraction)
 */
function parseSubtitleText(textContent: string): SubtitleEntry[] {
  console.log('[PureSubs] Parsing plain text as subtitle entries');
  const entries: SubtitleEntry[] = [];
  
  // Split text into lines and create entries
  const lines = textContent.split('\n').filter(line => line.trim());
  
  lines.forEach((line, index) => {
    const text = cleanSubtitleText(line);
    if (text.trim()) {
      // Assign approximate timing based on line position
      const start = index * 3; // 3 seconds per line
      entries.push({
        start: start,
        end: start + 2.5, // 2.5 second duration
        text: text
      });
    }
  });
  
  console.log(`[PureSubs] Created ${entries.length} entries from plain text`);
  return entries;
}

/**
 * Parse subtitle XML content into structured data
 */
export function parseSubtitleXML(xmlContent: string): SubtitleEntry[] {
  try {
    console.log('[PureSubs] Parsing subtitle XML, content length:', xmlContent.length);
    const entries: SubtitleEntry[] = [];

    // 如果内容不包含XML标签，尝试作为纯文本处理
    if (!xmlContent.includes('<') || !xmlContent.includes('>')) {
      console.log('[PureSubs] Content appears to be plain text, not XML');
      return parseSubtitleText(xmlContent);
    }

    // 一个更全面的正则表达式数组，以应对多种YouTube字幕格式
    const textPatterns = [
      // 标准格式: <text start="12.34" dur="2.5">Hello world</text>
      /<text start="([^"]+)"(?:\s+dur="([^"]+)")?>([^<]*)<\/text>/g,
      // srv3 格式 (毫秒): <p t="12340" d="2500">Hello world</p>
      /<p t="([^"]+)"(?:\s+d="([^"]+)")?>([^<]*)<\/p>/g,
      // 包含更多属性的格式
      /<text[^>]+start="([^"]+)"[^>]*(?:dur="([^"]+)")?[^>]*>([^<]*)<\/text>/g,
      // srv1 格式 with t/d attributes
      /<text[^>]*t="([^"]+)"[^>]*(?:d="([^"]+)")?[^>]*>([^<]*)<\/text>/g,
      // 一个更灵活的"最终防线"模式，匹配 text 或 p 标签
      /<(?:text|p)[^>]*(?:start|t)="([^"]+)"[^>]*(?:(?:dur|d)="([^"]+)")?[^>]*>([^<]*)<\/(?:text|p)>/g
    ];

    let matchCount = 0;

    // 依次尝试每个正则表达式，直到成功解析出内容
    for (const textRegex of textPatterns) {
      console.log('[PureSubs] Trying pattern:', textRegex);
      textRegex.lastIndex = 0; // 重置正则状态

      let match;
      while ((match = textRegex.exec(xmlContent)) !== null) {
        matchCount++;
        let start = parseFloat(match[1]);
        let duration = match[2] ? parseFloat(match[2]) : 2.0; // 默认2秒时长
        const rawText = match[3];

        // srv3格式使用毫秒，需要转换
        if (start > 10000) { // 如果开始时间大于10000，基本可以断定是毫秒
          start /= 1000;
          if (duration > 0) {
            duration /= 1000;
          }
        }

        const text = cleanSubtitleText(rawText);

        if (matchCount <= 5) {
          console.log(`[PureSubs] Match ${matchCount}:`, { start, duration, rawText, cleanedText: text });
        }

        if (text.trim()) {
          entries.push({
            start: start,
            end: start + duration,
            text: text
          });
        }
      }

      // 如果当前正则表达式已经找到了匹配项，就无需尝试下一个了
      if (matchCount > 0) {
        console.log(`[PureSubs] Successfully used pattern: ${textRegex}, found ${matchCount} matches`);
        break;
      }
    }

    // 如果XML解析失败，尝试作为纯文本处理
    if (matchCount === 0) {
      console.log('[PureSubs] XML patterns failed, trying plain text parsing...');
      return parseSubtitleText(xmlContent);
    }

    console.log(`[PureSubs] Found ${matchCount} total matches, parsed ${entries.length} valid entries`);

    // 确保按开始时间排序
    const sortedEntries = entries.sort((a, b) => a.start - b.start);
    console.log('[PureSubs] First 3 parsed entries:', sortedEntries.slice(0, 3));
    return sortedEntries;
  } catch (error) {
    console.error('[PureSubs] Failed to parse subtitle XML:', error);
    throw new Error(`Failed to parse subtitle XML: ${error}`);
  }
}

/**
 * Clean subtitle text by removing HTML tags and fixing encoding
 */
export function cleanSubtitleText(text: string): string {
  if (!text) return '';

  return text
    // Remove HTML tags first (before decoding entities that might contain < >)
    .replace(/<[^>]*>/g, '')
    // Decode common HTML entities
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&#x27;/g, "'")
    .replace(/&#x2F;/g, '/')
    // Decode numeric entities
    .replace(/&#(\d+);/g, (match, num) => String.fromCharCode(parseInt(num, 10)))
    .replace(/&#x([a-fA-F0-9]+);/g, (match, hex) => String.fromCharCode(parseInt(hex, 16)))
    // Clean up extra whitespace
    .replace(/\s+/g, ' ')
    .trim();
}

/**
 * Convert subtitle entries to SRT format
 */
export function convertToSRT(entries: SubtitleEntry[]): string {
  console.log(`[PureSubs] Converting ${entries?.length || 0} entries to SRT format`);
  
  if (!entries || entries.length === 0) {
    console.warn('[PureSubs] No entries to convert to SRT');
    return '';
  }
  
  const srtContent = entries
    .map((entry, index) => {
      const startTime = formatSRTTimestamp(entry.start);
      const endTime = formatSRTTimestamp(entry.end);
      
      const srtBlock = [
        (index + 1).toString(),
        `${startTime} --> ${endTime}`,
        entry.text,
        ''
      ].join('\n');
      
      if (index < 3) {
        console.log(`[PureSubs] SRT block ${index + 1}:`, srtBlock);
      }
      
      return srtBlock;
    })
    .join('\n');
    
  console.log(`[PureSubs] Generated SRT content length: ${srtContent.length}`);
  return srtContent;
}

/**
 * Convert subtitle entries to plain text format
 */
export function convertToTXT(entries: SubtitleEntry[], separator: string = '\n'): string {
  console.log(`[PureSubs] Converting ${entries?.length || 0} entries to TXT format`);
  
  if (!entries || entries.length === 0) {
    console.warn('[PureSubs] No entries to convert to TXT');
    return '';
  }
  
  const txtContent = entries.map(entry => entry.text.trim()).join(separator);
  console.log(`[PureSubs] Generated TXT content length: ${txtContent.length}`);
  return txtContent;
}

/**
 * Format time in seconds to SRT timestamp format (HH:MM:SS,mmm)
 */
export function formatSRTTimestamp(seconds: number): string {
  // Handle negative values by clamping to 0
  if (seconds < 0) {
    seconds = 0;
  }
  
  // Round to 3 decimal places to avoid floating point precision issues
  const roundedSeconds = Math.round(seconds * 1000) / 1000;
  
  const hours = Math.floor(roundedSeconds / 3600);
  const minutes = Math.floor((roundedSeconds % 3600) / 60);
  const secs = Math.floor(roundedSeconds % 60);
  const milliseconds = Math.round((roundedSeconds % 1) * 1000);
  
  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${milliseconds.toString().padStart(3, '0')}`;
}

/**
 * Select the best subtitle based on smart priority logic
 * Priority: 中文 (zh-Hans, zh-CN, zh) -> 英文 (en) -> 其他语言
 */
export function selectBestSubtitle(availableSubtitles: SubtitleTrack[]): SubtitleTrack | null {
  if (!availableSubtitles || availableSubtitles.length === 0) {
    return null;
  }

  // 优先级定义：中文变体
  const chineseLanguages = ['zh-Hans', 'zh-CN', 'zh', 'zh-TW', 'zh-HK'];
  const englishLanguages = ['en', 'en-US', 'en-GB'];

  // Step 1: 查找中文字幕 (优先人工字幕)
  for (const lang of chineseLanguages) {
    // 首先查找人工中文字幕
    const manualChinese = availableSubtitles.find(sub => 
      sub.language === lang && !sub.isAutoGenerated
    );
    if (manualChinese) {
      console.log('[PureSubs] Selected manual Chinese subtitles:', lang);
      return manualChinese;
    }
  }

  // Step 2: 查找自动生成的中文字幕
  for (const lang of chineseLanguages) {
    const autoChinese = availableSubtitles.find(sub => 
      sub.language === lang && sub.isAutoGenerated
    );
    if (autoChinese) {
      console.log('[PureSubs] Selected auto-generated Chinese subtitles:', lang);
      return autoChinese;
    }
  }

  // Step 3: 查找英文字幕 (优先人工字幕)
  for (const lang of englishLanguages) {
    const manualEnglish = availableSubtitles.find(sub => 
      sub.language === lang && !sub.isAutoGenerated
    );
    if (manualEnglish) {
      console.log('[PureSubs] Selected manual English subtitles:', lang);
      return manualEnglish;
    }
  }

  // Step 4: 查找自动生成的英文字幕
  for (const lang of englishLanguages) {
    const autoEnglish = availableSubtitles.find(sub => 
      sub.language === lang && sub.isAutoGenerated
    );
    if (autoEnglish) {
      console.log('[PureSubs] Selected auto-generated English subtitles:', lang);
      return autoEnglish;
    }
  }

  // Step 5: 如果没有中文和英文，返回第一个可用的字幕
  const fallback = availableSubtitles[0];
  console.log('[PureSubs] Using fallback subtitle:', fallback.language);
  return fallback;
}

/**
 * Main function to extract YouTube data from current page
 * This works in Chrome extension context without external dependencies
 */
export async function getYouTubeDataFromPage(options: ExtractOptions = {}): Promise<YouTubeVideoData> {
  try {
    // Step 1: Extract ytInitialPlayerResponse from current page
    const playerResponse = extractPlayerResponseFromPage();
    
    // Step 2: Extract video metadata
    const metadata = extractVideoMetadata(playerResponse);
    
    // Step 3: Extract available subtitle tracks
    const availableSubtitles = extractSubtitleTracks(playerResponse);
    
    // Step 4: Extract subtitles if requested
    let subtitles;
    if (options.extractSubtitles && availableSubtitles.length > 0) {
      console.log('[PureSubs] 🎯 Extracting subtitles using 2025 spy injection method...');
      
      // 选择最佳字幕
      let selectedSubtitle = null;
      if (options.subtitleLanguage) {
        selectedSubtitle = availableSubtitles.find(track => track.language === options.subtitleLanguage);
      }
      if (!selectedSubtitle) {
        selectedSubtitle = selectBestSubtitle(availableSubtitles);
      }
      
      if (selectedSubtitle) {
        console.log('[PureSubs] 🎭 Selected subtitle track:', selectedSubtitle);
        
        try {
          // 🕵️ 新策略：使用注入的间谍脚本拦截数据
          const videoId = extractVideoIdFromCurrentURL();
          
          // 首先检查是否已经有拦截到的数据
          let spyData = getInterceptedSubtitleData(videoId, selectedSubtitle.language);
          
          if (!spyData) {
            console.log('[PureSubs] 🔍 No spy data found yet, triggering subtitle loading...');
            
            // 检查间谍脚本状态
            await checkSpyStatus();
            
            // 触发字幕加载（模拟用户操作）
            await triggerSubtitleLoading();
            
            // 等待间谍拦截数据
            console.log('[PureSubs] ⏳ Waiting for spy to intercept subtitle data...');
            spyData = await waitForSpyData(videoId, selectedSubtitle.language, 5000);
          }
          
          if (spyData && spyData.content) {
            console.log('[PureSubs] 🎉 Using intercepted spy data!');
            console.log(`[PureSubs] 📊 Data format: ${spyData.format}, length: ${spyData.content.length}`);
            
            // 解析不同格式的字幕数据
            let entries: SubtitleEntry[] = [];
            
            if (spyData.format === 'json3' || spyData.content.includes('"events"')) {
              // JSON3格式
              entries = parseJSON3Subtitles(spyData.content);
            } else if (spyData.content.includes('<transcript>') || spyData.content.includes('<text')) {
              // XML格式
              entries = parseSubtitleXML(spyData.content);
            } else {
              // 尝试作为JSON解析
              try {
                const jsonData = JSON.parse(spyData.content);
                if (jsonData.events) {
                  entries = parseJSON3Subtitles(spyData.content);
                }
              } catch {
                console.warn('[PureSubs] ⚠️ Unknown subtitle format, attempting plain text parsing');
                entries = parseSubtitleTextFallback(spyData.content);
              }
            }
            
            if (entries.length > 0) {
              console.log(`[PureSubs] ✅ Successfully parsed ${entries.length} subtitle entries`);
              
              subtitles = {
                srt: convertToSRT(entries),
                txt: convertToTXT(entries),
                entries: entries
              };
            } else {
              throw new Error('Failed to parse intercepted subtitle data');
            }
            
          } else {
            throw new Error('No subtitle data intercepted by spy');
          }
          
        } catch (spyError: any) {
          console.error('[PureSubs] 🚨 Spy interception method failed:', spyError);
          
          // 🚫 移除了会导致 ChunkLoadError 的备选方案
          // 直接提供用户友好的错误信息，而不是尝试其他可能失败的方法
          console.log('[PureSubs] ℹ️ Primary spy method failed, providing user guidance...');
          
          const errorMessage = `🚨 字幕获取失败

视频: ${metadata.title}

可能的原因：
- YouTube 更新了页面结构
- 字幕数据尚未加载完成
- 网络连接问题

建议解决方案：
1. 刷新页面后重试
2. 确保视频正在播放
3. 在YouTube播放器中手动开启字幕
4. 稍等片刻后再次尝试下载

PureSubs Team - 2025`;

          subtitles = {
            srt: `1\n00:00:00,000 --> 00:00:15,000\n${errorMessage}\n\n`,
            txt: errorMessage,
            entries: [{
              start: 0,
              end: 15,
              text: errorMessage
            }]
          };
        }
      } else {
        console.log('[PureSubs] ❌ No suitable subtitle track found');
        const noSubsMessage = `📺 该视频暂无可用字幕

视频: ${metadata.title}

检测结果：
- 可用字幕轨道：${availableSubtitles.length}个
- 支持的语言：${availableSubtitles.map(track => `${track.name} (${track.language})`).join(', ') || '无'}
- 间谍脚本状态：已注入

此视频可能：
1. 没有上传字幕文件
2. 字幕仅对特定地区开放  
3. 需要在YouTube播放器中手动开启

建议在YouTube播放器设置中检查字幕选项。

PureSubs Team`;

        subtitles = {
          srt: `1\n00:00:00,000 --> 00:00:08,000\n${noSubsMessage}\n\n`,
          txt: noSubsMessage,
          entries: [{
            start: 0,
            end: 8,
            text: noSubsMessage
          }]
        };
      }
    }
    
    return {
      title: metadata.title,
      description: metadata.description,
      availableSubtitles,
      subtitles
    };
  } catch (error) {
    console.error('[PureSubs] 💥 Failed to extract YouTube data:', error);
    throw new Error(`Failed to extract YouTube data: ${error}`);
  }
}

/**
 * 检查间谍脚本状态
 */
async function checkSpyStatus(): Promise<void> {
  return new Promise((resolve) => {
    const timeout = setTimeout(() => {
      console.log('[PureSubs] ⏰ Spy status check timeout');
      resolve();
    }, 1000);
    
    const handleMessage = (event: MessageEvent) => {
      if (event.data?.type === 'PURESUBS_SPY_STATUS') {
        console.log('[PureSubs] 📊 Spy status received:', event.data.data);
        window.removeEventListener('message', handleMessage);
        clearTimeout(timeout);
        resolve();
      }
    };
    
    window.addEventListener('message', handleMessage);
    
    // 请求间谍状态
    window.postMessage({ type: 'PURESUBS_REQUEST_STATUS' }, '*');
  });
}

/**
 * 等待间谍拦截数据 - 使用统一的Promise唤醒机制
 */
async function waitForSpyData(videoId: string, language: string, timeoutMs: number = 5000): Promise<any> {
  // 🎯 使用content script的统一Promise机制
  const contentScript = (window as any).puresubsContentScript;
  
  if (contentScript && contentScript.waitForSpyData) {
    console.log('[PureSubs] 🔄 Using content script Promise mechanism for waiting...');
    try {
      return await contentScript.waitForSpyData(videoId, language, timeoutMs);
    } catch (error) {
      console.log('[PureSubs] ⏰ Content script waiting timeout:', String(error));
      return null;
    }
  }
  
  // 🔙 回退到原有逻辑（如果content script接口不可用）
  console.log('[PureSubs] ⚠️ Content script interface not available, using fallback...');
  return new Promise((resolve) => {
    const timeout = setTimeout(() => {
      console.log('[PureSubs] ⏰ Waiting for spy data timeout');
      resolve(null);
    }, timeoutMs);
    
    const handleMessage = (event: MessageEvent) => {
      if (event.data?.type === 'PURESUBS_SUBTITLE_INTERCEPTED') {
        const data = event.data.data;
        if (data.videoId === videoId && (data.language === language || !language)) {
          console.log('[PureSubs] 🎯 Got matching spy data!');
          window.removeEventListener('message', handleMessage);
          clearTimeout(timeout);
          resolve(data);
        }
      }
    };
    
    window.addEventListener('message', handleMessage);
  });
}

/**
 * 简单的文本解析（作为最后回退）
 */
function parseSubtitleTextFallback(content: string): SubtitleEntry[] {
  const lines = content.split('\n').filter(line => line.trim());
  const entries: SubtitleEntry[] = [];
  
  lines.forEach((line, index) => {
    if (line.trim()) {
      entries.push({
        start: index * 3,
        end: (index + 1) * 3,
        text: line.trim()
      });
    }
  });
  
  return entries;
}

/**
 * 从当前URL提取视频ID
 */
function extractVideoIdFromCurrentURL(): string {
  const urlParams = new URLSearchParams(window.location.search);
  return urlParams.get('v') || '';
}

/**
 * 触发字幕加载（模拟用户操作）
 */
async function triggerSubtitleLoading(): Promise<void> {
  try {
    console.log('[PureSubs] Attempting to trigger subtitle loading...');
    
    // 查找字幕按钮
    const captionButton = document.querySelector('[data-title-no-tooltip="Subtitles/closed captions unavailable"], [data-title-no-tooltip*="subtitle"], .ytp-subtitles-button, .ytp-cc-button');
    
    if (captionButton && captionButton instanceof HTMLElement) {
      console.log('[PureSubs] Found caption button, attempting to click...');
      captionButton.click();
      
      // 等待一下让菜单加载
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // 查找第一个字幕选项
      const subtitleOption = document.querySelector('.ytp-menuitem[role="menuitemradio"]');
      if (subtitleOption && subtitleOption instanceof HTMLElement) {
        console.log('[PureSubs] Found subtitle option, clicking...');
        subtitleOption.click();
      }
    } else {
      console.log('[PureSubs] Caption button not found, subtitle loading may not be triggered');
    }
  } catch (error) {
    console.error('[PureSubs] Error triggering subtitle loading:', error);
  }
}