/**
 * Browser-specific implementation of PureSubs core engine
 * This version uses browser fetch API and runs in Chrome extension context
 */

export interface SubtitleTrack {
  /** Language code (e.g., 'en', 'zh-Hans') */
  language: string;
  /** Human readable language name */
  name: string;
  /** Whether this is auto-generated or manual */
  isAutoGenerated: boolean;
  /** URL to the subtitle XML file */
  baseUrl: string;
}

export interface SubtitleEntry {
  /** Start time in seconds */
  start: number;
  /** End time in seconds */
  end: number;
  /** Subtitle text content */
  text: string;
}

export interface YouTubeVideoData {
  /** Video title */
  title: string;
  /** Video description */
  description: string;
  /** Available subtitle tracks */
  availableSubtitles: SubtitleTrack[];
  /** Extracted subtitles in different formats */
  subtitles?: {
    /** SRT format with timestamps */
    srt: string;
    /** Plain text format */
    txt: string;
    /** Raw subtitle entries */
    entries: SubtitleEntry[];
  };
}

export interface ExtractOptions {
  /** Preferred language codes in order of preference */
  preferredLanguages?: string[];
  /** Whether to include auto-generated subtitles */
  includeAutoGenerated?: boolean;
  /** Whether to extract subtitle content (default: false) */
  extractSubtitles?: boolean;
  /** Target language for subtitle extraction */
  subtitleLanguage?: string;
}

/**
 * Extract ytInitialPlayerResponse from current page
 * This works in Chrome extension content script context
 */
export function extractPlayerResponseFromPage(): any {
  try {
    console.log('[PureSubs] Starting to extract ytInitialPlayerResponse from page');
    const scripts = document.querySelectorAll('script');
    console.log(`[PureSubs] Found ${scripts.length} script tags`);
    
    for (let i = 0; i < scripts.length; i++) {
      const script = scripts[i];
      const content = script.innerHTML;
      
      // Try different patterns for ytInitialPlayerResponse
      const patterns = [
        // Most common: var ytInitialPlayerResponse = {...};
        /var ytInitialPlayerResponse\s*=\s*(\{.+?\});/s,
        // Alternative: ytInitialPlayerResponse = {...}
        /ytInitialPlayerResponse\s*=\s*(\{.+?\});/s,
        // In JSON context
        /"ytInitialPlayerResponse":\s*(\{.+?\})/s,
        // Window context
        /window\["ytInitialPlayerResponse"\]\s*=\s*(\{.+?\});/s,
        // Direct assignment with brackets
        /ytInitialPlayerResponse["\s]*[:=]\s*(\{.+?\})/s
      ];
      
      for (const pattern of patterns) {
        const match = content.match(pattern);
        if (match) {
          console.log('[PureSubs] Found ytInitialPlayerResponse with pattern:', pattern);
          const playerResponse = JSON.parse(match[1]);
          console.log('[PureSubs] Parsed playerResponse:', playerResponse);
          return playerResponse;
        }
      }
    }
    
    console.error('[PureSubs] Could not find ytInitialPlayerResponse in any script tag');
    throw new Error('Could not find ytInitialPlayerResponse in page');
  } catch (error) {
    console.error('[PureSubs] Error parsing ytInitialPlayerResponse:', error);
    throw new Error(`Failed to parse ytInitialPlayerResponse: ${error}`);
  }
}

/**
 * Extract video metadata from player response
 */
export function extractVideoMetadata(playerResponse: any): {
  title: string;
  description: string;
} {
  try {
    const videoDetails = playerResponse.videoDetails;
    
    if (!videoDetails) {
      throw new Error('No videoDetails found in playerResponse');
    }
    
    return {
      title: videoDetails.title || 'Untitled',
      description: videoDetails.shortDescription || ''
    };
  } catch (error) {
    throw new Error(`Failed to extract video metadata: ${error}`);
  }
}

/**
 * Extract subtitle tracks from player response
 */
export function extractSubtitleTracks(playerResponse: any): SubtitleTrack[] {
  try {
    console.log('[PureSubs] Extracting subtitle tracks from playerResponse');
    console.log('[PureSubs] PlayerResponse captions:', playerResponse?.captions);
    
    const captionsArray = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
    console.log('[PureSubs] Found captionTracks:', captionsArray);
    
    if (!captionsArray || !Array.isArray(captionsArray)) {
      console.warn('[PureSubs] No caption tracks found or not array');
      return [];
    }
    
    const tracks = captionsArray.map((caption: any): SubtitleTrack => {
      const track = {
        language: caption.languageCode || 'unknown',
        name: caption.name?.simpleText || caption.name?.runs?.[0]?.text || 'Unknown',
        isAutoGenerated: caption.kind === 'asr',
        baseUrl: caption.baseUrl
      };
      console.log('[PureSubs] Processed track:', track);
      return track;
    });
    
    console.log(`[PureSubs] Extracted ${tracks.length} subtitle tracks:`, tracks);
    return tracks;
  } catch (error) {
    console.error('[PureSubs] Failed to extract subtitle tracks:', error);
    return [];
  }
}

/**
 * Fetch subtitle XML content by delegating the request to the background script.
 * This is the correct way to handle cross-origin fetches with custom headers in MV3.
 */
export async function fetchSubtitleXML(subtitleUrl: string): Promise<string> {
  console.log('[PureSubs] Delegating fetch request to background script for URL:', subtitleUrl);

  // 定义一个函数，用于向后台发送消息并等待响应
  const fetchFromBackground = (url: string): Promise<string> => {
    return new Promise((resolve, reject) => {
      chrome.runtime.sendMessage(
        { type: 'FETCH_SUBTITLE_XML', payload: { url } },
        (response) => {
          if (chrome.runtime.lastError) {
            console.error('[PureSubs] Runtime error:', chrome.runtime.lastError.message);
            return reject(new Error(chrome.runtime.lastError.message));
          }
          if (response?.success) {
            console.log(`[PureSubs] Received content from background, length: ${response.content?.length || 0}`);
            console.log(`[PureSubs] Content preview:`, response.content?.substring(0, 500) || '');
            resolve(response.content || '');
          } else {
            const errorMessage = response?.error || 'Unknown error from background script';
            console.error('[PureSubs] Background script failed to fetch:', errorMessage);
            reject(new Error(errorMessage));
          }
        }
      );
    });
  };

  try {
    // 1. 首先尝试原始 URL
    let xmlContent = await fetchFromBackground(subtitleUrl);
    if (xmlContent && xmlContent.length > 0) {
      return xmlContent;
    }

    // 2. 如果原始 URL 返回空，再尝试备用方案
    console.log('[PureSubs] Original URL returned empty, trying alternatives via background script...');
    const url = new URL(subtitleUrl);
    const videoId = url.searchParams.get('v');
    const lang = url.searchParams.get('lang');

    if (videoId && lang) {
      const alternativeUrls = [
        `https://www.youtube.com/api/timedtext?v=${videoId}&lang=${lang}&fmt=srv3`,
        `https://www.youtube.com/api/timedtext?v=${videoId}&lang=${lang}`,
        `https://www.youtube.com/api/timedtext?v=${videoId}&lang=${lang}&fmt=srv1`
      ];

      for (const altUrl of alternativeUrls) {
        console.log('[PureSubs] Trying alternative URL via background:', altUrl);
        try {
          const altContent = await fetchFromBackground(altUrl);
          if (altContent && altContent.length > 0) {
            console.log('[PureSubs] Success with alternative URL!');
            return altContent;
          }
        } catch (error) {
          console.log(`[PureSubs] Alternative URL failed:`, error);
        }
      }
    }

    // 3. 如果所有方法都失败，返回空字符串
    console.warn('[PureSubs] All fetch attempts via background script returned empty content.');
    return '';

  } catch (error) {
    console.error('[PureSubs] Failed to fetch subtitle XML via background script:', error);
    throw new Error(`Failed to fetch subtitle XML: ${error}`);
  }
}

/**
 * Parse plain text into subtitle entries (fallback for DOM extraction)
 */
function parseSubtitleText(textContent: string): SubtitleEntry[] {
  console.log('[PureSubs] Parsing plain text as subtitle entries');
  const entries: SubtitleEntry[] = [];
  
  // Split text into lines and create entries
  const lines = textContent.split('\n').filter(line => line.trim());
  
  lines.forEach((line, index) => {
    const text = cleanSubtitleText(line);
    if (text.trim()) {
      // Assign approximate timing based on line position
      const start = index * 3; // 3 seconds per line
      entries.push({
        start: start,
        end: start + 2.5, // 2.5 second duration
        text: text
      });
    }
  });
  
  console.log(`[PureSubs] Created ${entries.length} entries from plain text`);
  return entries;
}

/**
 * Parse subtitle XML content into structured data
 */
export function parseSubtitleXML(xmlContent: string): SubtitleEntry[] {
  try {
    console.log('[PureSubs] Parsing subtitle XML, content length:', xmlContent.length);
    const entries: SubtitleEntry[] = [];

    // 如果内容不包含XML标签，尝试作为纯文本处理
    if (!xmlContent.includes('<') || !xmlContent.includes('>')) {
      console.log('[PureSubs] Content appears to be plain text, not XML');
      return parseSubtitleText(xmlContent);
    }

    // 一个更全面的正则表达式数组，以应对多种YouTube字幕格式
    const textPatterns = [
      // 标准格式: <text start="12.34" dur="2.5">Hello world</text>
      /<text start="([^"]+)"(?:\s+dur="([^"]+)")?>([^<]*)<\/text>/g,
      // srv3 格式 (毫秒): <p t="12340" d="2500">Hello world</p>
      /<p t="([^"]+)"(?:\s+d="([^"]+)")?>([^<]*)<\/p>/g,
      // 包含更多属性的格式
      /<text[^>]+start="([^"]+)"[^>]*(?:dur="([^"]+)")?[^>]*>([^<]*)<\/text>/g,
      // srv1 格式 with t/d attributes
      /<text[^>]*t="([^"]+)"[^>]*(?:d="([^"]+)")?[^>]*>([^<]*)<\/text>/g,
      // 一个更灵活的"最终防线"模式，匹配 text 或 p 标签
      /<(?:text|p)[^>]*(?:start|t)="([^"]+)"[^>]*(?:(?:dur|d)="([^"]+)")?[^>]*>([^<]*)<\/(?:text|p)>/g
    ];

    let matchCount = 0;

    // 依次尝试每个正则表达式，直到成功解析出内容
    for (const textRegex of textPatterns) {
      console.log('[PureSubs] Trying pattern:', textRegex);
      textRegex.lastIndex = 0; // 重置正则状态

      let match;
      while ((match = textRegex.exec(xmlContent)) !== null) {
        matchCount++;
        let start = parseFloat(match[1]);
        let duration = match[2] ? parseFloat(match[2]) : 2.0; // 默认2秒时长
        let rawText = match[3];

        // srv3格式使用毫秒，需要转换
        if (start > 10000) { // 如果开始时间大于10000，基本可以断定是毫秒
          start /= 1000;
          if (duration > 0) {
            duration /= 1000;
          }
        }

        const text = cleanSubtitleText(rawText);

        if (matchCount <= 5) {
          console.log(`[PureSubs] Match ${matchCount}:`, { start, duration, rawText, cleanedText: text });
        }

        if (text.trim()) {
          entries.push({
            start: start,
            end: start + duration,
            text: text
          });
        }
      }

      // 如果当前正则表达式已经找到了匹配项，就无需尝试下一个了
      if (matchCount > 0) {
        console.log(`[PureSubs] Successfully used pattern: ${textRegex}, found ${matchCount} matches`);
        break;
      }
    }

    // 如果XML解析失败，尝试作为纯文本处理
    if (matchCount === 0) {
      console.log('[PureSubs] XML patterns failed, trying plain text parsing...');
      return parseSubtitleText(xmlContent);
    }

    console.log(`[PureSubs] Found ${matchCount} total matches, parsed ${entries.length} valid entries`);

    // 确保按开始时间排序
    const sortedEntries = entries.sort((a, b) => a.start - b.start);
    console.log('[PureSubs] First 3 parsed entries:', sortedEntries.slice(0, 3));
    return sortedEntries;
  } catch (error) {
    console.error('[PureSubs] Failed to parse subtitle XML:', error);
    throw new Error(`Failed to parse subtitle XML: ${error}`);
  }
}

/**
 * Clean subtitle text by removing HTML tags and fixing encoding
 */
export function cleanSubtitleText(text: string): string {
  if (!text) return '';

  return text
    // Decode common HTML entities (order matters - do this first)
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&#x27;/g, "'")
    .replace(/&#x2F;/g, '/')
    // Decode numeric entities
    .replace(/&#(\d+);/g, (match, num) => String.fromCharCode(parseInt(num, 10)))
    .replace(/&#x([a-fA-F0-9]+);/g, (match, hex) => String.fromCharCode(parseInt(hex, 16)))
    // Remove HTML tags
    .replace(/<[^>]*>/g, '')
    // Clean up extra whitespace
    .replace(/\s+/g, ' ')
    .trim();
}

/**
 * Convert subtitle entries to SRT format
 */
export function convertToSRT(entries: SubtitleEntry[]): string {
  console.log(`[PureSubs] Converting ${entries?.length || 0} entries to SRT format`);
  
  if (!entries || entries.length === 0) {
    console.warn('[PureSubs] No entries to convert to SRT');
    return '';
  }
  
  const srtContent = entries
    .map((entry, index) => {
      const startTime = formatSRTTimestamp(entry.start);
      const endTime = formatSRTTimestamp(entry.end);
      
      const srtBlock = [
        (index + 1).toString(),
        `${startTime} --> ${endTime}`,
        entry.text,
        ''
      ].join('\n');
      
      if (index < 3) {
        console.log(`[PureSubs] SRT block ${index + 1}:`, srtBlock);
      }
      
      return srtBlock;
    })
    .join('\n');
    
  console.log(`[PureSubs] Generated SRT content length: ${srtContent.length}`);
  return srtContent;
}

/**
 * Convert subtitle entries to plain text format
 */
export function convertToTXT(entries: SubtitleEntry[], separator: string = '\n'): string {
  console.log(`[PureSubs] Converting ${entries?.length || 0} entries to TXT format`);
  
  if (!entries || entries.length === 0) {
    console.warn('[PureSubs] No entries to convert to TXT');
    return '';
  }
  
  const txtContent = entries.map(entry => entry.text.trim()).join(separator);
  console.log(`[PureSubs] Generated TXT content length: ${txtContent.length}`);
  return txtContent;
}

/**
 * Format time in seconds to SRT timestamp format (HH:MM:SS,mmm)
 */
export function formatSRTTimestamp(seconds: number): string {
  // Round to 3 decimal places to avoid floating point precision issues
  const roundedSeconds = Math.round(seconds * 1000) / 1000;
  
  const hours = Math.floor(roundedSeconds / 3600);
  const minutes = Math.floor((roundedSeconds % 3600) / 60);
  const secs = Math.floor(roundedSeconds % 60);
  const milliseconds = Math.round((roundedSeconds % 1) * 1000);
  
  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${milliseconds.toString().padStart(3, '0')}`;
}

/**
 * Select the best subtitle based on smart priority logic
 * Priority: 中文 (zh-Hans, zh-CN, zh) -> 英文 (en) -> 其他语言
 */
export function selectBestSubtitle(availableSubtitles: SubtitleTrack[]): SubtitleTrack | null {
  if (!availableSubtitles || availableSubtitles.length === 0) {
    return null;
  }

  // 优先级定义：中文变体
  const chineseLanguages = ['zh-Hans', 'zh-CN', 'zh', 'zh-TW', 'zh-HK'];
  const englishLanguages = ['en', 'en-US', 'en-GB'];

  // Step 1: 查找中文字幕 (优先人工字幕)
  for (const lang of chineseLanguages) {
    // 首先查找人工中文字幕
    const manualChinese = availableSubtitles.find(sub => 
      sub.language === lang && !sub.isAutoGenerated
    );
    if (manualChinese) {
      console.log('[PureSubs] Selected manual Chinese subtitles:', lang);
      return manualChinese;
    }
  }

  // Step 2: 查找自动生成的中文字幕
  for (const lang of chineseLanguages) {
    const autoChinese = availableSubtitles.find(sub => 
      sub.language === lang && sub.isAutoGenerated
    );
    if (autoChinese) {
      console.log('[PureSubs] Selected auto-generated Chinese subtitles:', lang);
      return autoChinese;
    }
  }

  // Step 3: 查找英文字幕 (优先人工字幕)
  for (const lang of englishLanguages) {
    const manualEnglish = availableSubtitles.find(sub => 
      sub.language === lang && !sub.isAutoGenerated
    );
    if (manualEnglish) {
      console.log('[PureSubs] Selected manual English subtitles:', lang);
      return manualEnglish;
    }
  }

  // Step 4: 查找自动生成的英文字幕
  for (const lang of englishLanguages) {
    const autoEnglish = availableSubtitles.find(sub => 
      sub.language === lang && sub.isAutoGenerated
    );
    if (autoEnglish) {
      console.log('[PureSubs] Selected auto-generated English subtitles:', lang);
      return autoEnglish;
    }
  }

  // Step 5: 如果没有中文和英文，返回第一个可用的字幕
  const fallback = availableSubtitles[0];
  console.log('[PureSubs] Using fallback subtitle:', fallback.language);
  return fallback;
}

/**
 * Main function to extract YouTube data from current page
 * This works in Chrome extension context without external dependencies
 */
export async function getYouTubeDataFromPage(options: ExtractOptions = {}): Promise<YouTubeVideoData> {
  try {
    // Step 1: Extract ytInitialPlayerResponse from current page
    const playerResponse = extractPlayerResponseFromPage();
    
    // Step 2: Extract video metadata
    const metadata = extractVideoMetadata(playerResponse);
    
    // Step 3: Extract available subtitle tracks
    const availableSubtitles = extractSubtitleTracks(playerResponse);
    
    // Step 4: Extract subtitles if requested
    let subtitles;
    if (options.extractSubtitles && availableSubtitles.length > 0) {
      const selectedSubtitle = selectBestSubtitle(availableSubtitles);
      
      if (selectedSubtitle) {
        // Fetch and parse subtitle content
        const xmlContent = await fetchSubtitleXML(selectedSubtitle.baseUrl);
        const entries = parseSubtitleXML(xmlContent);
        
        subtitles = {
          srt: convertToSRT(entries),
          txt: convertToTXT(entries),
          entries: entries
        };
      }
    }
    
    return {
      title: metadata.title,
      description: metadata.description,
      availableSubtitles,
      subtitles
    };
  } catch (error) {
    throw new Error(`Failed to extract YouTube data: ${error}`);
  }
}