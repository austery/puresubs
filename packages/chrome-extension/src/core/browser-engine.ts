/**
 * Browser-specific implementation of PureSubs core engine
 * This version uses browser fetch API and runs in Chrome extension context
 */

import { 
  parseJSON3Subtitles
} from './subtitle-interceptor';

// ğŸ’¡ é—´è°è„šæœ¬æ•°æ®æ¥å£
declare global {
  interface Window {
    PureSubsSpyData?: {
      [videoId: string]: {
        [language: string]: {
          content: string;
          format: string;
          timestamp: number;
        }
      }
    }
  }
}

/**
 * è·å–é—´è°è„šæœ¬æ‹¦æˆªçš„å­—å¹•æ•°æ®
 */
function getInterceptedSubtitleData(videoId: string, language: string): any {
  try {
    const spyData = window.PureSubsSpyData?.[videoId]?.[language];
    if (spyData && Date.now() - spyData.timestamp < 60000) { // 1åˆ†é’Ÿå†…çš„æ•°æ®æœ‰æ•ˆ
      return spyData;
    }
    return null;
  } catch (error) {
    console.warn('[PureSubs] Error accessing spy data:', error);
    return null;
  }
}

export interface SubtitleTrack {
  /** Language code (e.g., 'en', 'zh-Hans') */
  language: string;
  /** Human readable language name */
  name: string;
  /** Whether this is auto-generated or manual */
  isAutoGenerated: boolean;
  /** URL to the subtitle XML file */
  baseUrl: string;
}

export interface SubtitleEntry {
  /** Start time in seconds */
  start: number;
  /** End time in seconds */
  end: number;
  /** Subtitle text content */
  text: string;
}

export interface YouTubeVideoData {
  /** Video title */
  title: string;
  /** Video description */
  description: string;
  /** Available subtitle tracks */
  availableSubtitles: SubtitleTrack[];
  /** Extracted subtitles in different formats */
  subtitles?: {
    /** SRT format with timestamps */
    srt: string;
    /** Plain text format */
    txt: string;
    /** Raw subtitle entries */
    entries: SubtitleEntry[];
  };
}

export interface ExtractOptions {
  /** Preferred language codes in order of preference */
  preferredLanguages?: string[];
  /** Whether to include auto-generated subtitles */
  includeAutoGenerated?: boolean;
  /** Whether to extract subtitle content (default: false) */
  extractSubtitles?: boolean;
  /** Target language for subtitle extraction */
  subtitleLanguage?: string;
}

/**
 * Extract ytInitialPlayerResponse from current page
 * This works in Chrome extension content script context
 */
export function extractPlayerResponseFromPage(): any {
  try {
    console.log('[PureSubs] Starting to extract ytInitialPlayerResponse from page');
    const scripts = document.querySelectorAll('script');
    console.log(`[PureSubs] Found ${scripts.length} script tags`);
    
    for (let i = 0; i < scripts.length; i++) {
      const script = scripts[i];
      const content = script.innerHTML;
      
      // Try different patterns for ytInitialPlayerResponse
      const patterns = [
        // Most common: var ytInitialPlayerResponse = {...};
        /var ytInitialPlayerResponse\s*=\s*(\{.+?\});/s,
        // Alternative: ytInitialPlayerResponse = {...}
        /ytInitialPlayerResponse\s*=\s*(\{.+?\});/s,
        // In JSON context
        /"ytInitialPlayerResponse":\s*(\{.+?\})/s,
        // Window context
        /window\["ytInitialPlayerResponse"\]\s*=\s*(\{.+?\});/s,
        // Direct assignment with brackets
        /ytInitialPlayerResponse["\s]*[:=]\s*(\{.+?\})/s
      ];
      
      for (const pattern of patterns) {
        const match = content.match(pattern);
        if (match) {
          console.log('[PureSubs] Found ytInitialPlayerResponse with pattern:', pattern);
          try {
            const playerResponse = JSON.parse(match[1]);
            console.log('[PureSubs] Parsed playerResponse:', playerResponse);
            return playerResponse;
          } catch {
            console.warn('[PureSubs] Failed to parse JSON, trying next match');
            continue;
          }
        }
      }
    }
    
    console.warn('[PureSubs] Could not find ytInitialPlayerResponse in any script tag');
    return {};
  } catch (error) {
    console.error('[PureSubs] Error extracting ytInitialPlayerResponse:', error);
    return {};
  }
}

/**
 * Extract video metadata from player response
 */
export function extractVideoMetadata(playerResponse: any): {
  title: string;
  description: string;
} {
  try {
    const videoDetails = playerResponse?.videoDetails;
    
    if (!videoDetails) {
      console.warn('[PureSubs] No videoDetails found in playerResponse');
      return {
        title: 'Untitled',
        description: ''
      };
    }

    return {
      title: videoDetails.title || 'Untitled',
      description: videoDetails.shortDescription || ''
    };
  } catch (error) {
    console.error('[PureSubs] Error extracting video metadata:', error);
    return {
      title: 'Untitled',
      description: ''
    };
  }
}/**
 * Extract subtitle tracks from player response
 */
export function extractSubtitleTracks(playerResponse: any): SubtitleTrack[] {
  try {
    console.log('[PureSubs] Extracting subtitle tracks from playerResponse');
    console.log('[PureSubs] PlayerResponse captions:', playerResponse?.captions);
    
    const captionsArray = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
    console.log('[PureSubs] Found captionTracks:', captionsArray);
    
    if (!captionsArray || !Array.isArray(captionsArray)) {
      console.warn('[PureSubs] No caption tracks found or not array');
      return [];
    }
    
    const tracks = captionsArray.map((caption: any): SubtitleTrack => {
      const track = {
        language: caption.languageCode || 'unknown',
        name: caption.name?.simpleText || caption.name?.runs?.[0]?.text || 'Unknown',
        isAutoGenerated: caption.kind === 'asr',
        baseUrl: caption.baseUrl
      };
      console.log('[PureSubs] Processed track:', track);
      return track;
    });
    
    console.log(`[PureSubs] Extracted ${tracks.length} subtitle tracks:`, tracks);
    return tracks;
  } catch (error) {
    console.error('[PureSubs] Failed to extract subtitle tracks:', error);
    return [];
  }
}

/**
 * Fetch subtitle XML content by delegating the request to the background script.
 * This is the correct way to handle cross-origin fetches with custom headers in MV3.
 */
export async function fetchSubtitleXML(subtitleUrl: string): Promise<string> {
  console.log('[PureSubs] Delegating fetch request to background script for URL:', subtitleUrl);

  // å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºå‘åå°å‘é€æ¶ˆæ¯å¹¶ç­‰å¾…å“åº”
  const fetchFromBackground = (url: string): Promise<string> => {
    return new Promise((resolve, reject) => {
      chrome.runtime.sendMessage(
        { type: 'FETCH_SUBTITLE_XML', payload: { url } },
        (response) => {
          if (chrome.runtime.lastError) {
            console.error('[PureSubs] Runtime error:', chrome.runtime.lastError.message);
            return reject(new Error(chrome.runtime.lastError.message));
          }
          if (response?.success) {
            console.log(`[PureSubs] Received content from background, length: ${response.content?.length || 0}`);
            console.log(`[PureSubs] Content preview:`, response.content?.substring(0, 500) || '');
            resolve(response.content || '');
          } else {
            const errorMessage = response?.error || 'Unknown error from background script';
            console.error('[PureSubs] Background script failed to fetch:', errorMessage);
            reject(new Error(errorMessage));
          }
        }
      );
    });
  };

  try {
    // 1. é¦–å…ˆå°è¯•åŸå§‹ URL
    const xmlContent = await fetchFromBackground(subtitleUrl);
    if (xmlContent && xmlContent.length > 0) {
      return xmlContent;
    }

    console.log('[PureSubs] Original URL returned empty content, this might be due to YouTube API changes');
    console.log('[PureSubs] Note: YouTube may have changed their subtitle API access policy');
    
    // 2. å¦‚æœåŸå§‹ URL è¿”å›ç©ºï¼Œå¯èƒ½æ˜¯å› ä¸ºYouTube APIçš„é™åˆ¶
    // åœ¨å®é™…æƒ…å†µä¸‹ï¼Œè¿™éœ€è¦åœ¨æµè§ˆå™¨ç¯å¢ƒä¸­é€šè¿‡å…¶ä»–æ–¹å¼è·å–å­—å¹•
    console.warn('[PureSubs] YouTube subtitle API returned empty content. This is a known issue since 2023.');
    console.warn('[PureSubs] Possible solutions:');
    console.warn('[PureSubs] 1. Use browser extension context to access page data directly');
    console.warn('[PureSubs] 2. Extract subtitle data from page DOM if available');
    console.warn('[PureSubs] 3. Try alternative subtitle extraction methods');

    // è¿”å›ç©ºå­—ç¬¦ä¸²è€Œä¸æ˜¯æŠ›å‡ºé”™è¯¯ï¼Œè®©ä¸Šå±‚å¤„ç†
    return '';

  } catch (error) {
    console.error('[PureSubs] Failed to fetch subtitle XML via background script:', error);
    throw new Error(`Failed to fetch subtitle XML: ${error}`);
  }
}

/**
 * Parse plain text into subtitle entries (fallback for DOM extraction)
 */
function parseSubtitleText(textContent: string): SubtitleEntry[] {
  console.log('[PureSubs] Parsing plain text as subtitle entries');
  const entries: SubtitleEntry[] = [];
  
  // Split text into lines and create entries
  const lines = textContent.split('\n').filter(line => line.trim());
  
  lines.forEach((line, index) => {
    const text = cleanSubtitleText(line);
    if (text.trim()) {
      // Assign approximate timing based on line position
      const start = index * 3; // 3 seconds per line
      entries.push({
        start: start,
        end: start + 2.5, // 2.5 second duration
        text: text
      });
    }
  });
  
  console.log(`[PureSubs] Created ${entries.length} entries from plain text`);
  return entries;
}

/**
 * Parse subtitle XML content into structured data
 */
export function parseSubtitleXML(xmlContent: string): SubtitleEntry[] {
  try {
    console.log('[PureSubs] Parsing subtitle XML, content length:', xmlContent.length);
    const entries: SubtitleEntry[] = [];

    // å¦‚æœå†…å®¹ä¸åŒ…å«XMLæ ‡ç­¾ï¼Œå°è¯•ä½œä¸ºçº¯æ–‡æœ¬å¤„ç†
    if (!xmlContent.includes('<') || !xmlContent.includes('>')) {
      console.log('[PureSubs] Content appears to be plain text, not XML');
      return parseSubtitleText(xmlContent);
    }

    // ä¸€ä¸ªæ›´å…¨é¢çš„æ­£åˆ™è¡¨è¾¾å¼æ•°ç»„ï¼Œä»¥åº”å¯¹å¤šç§YouTubeå­—å¹•æ ¼å¼
    const textPatterns = [
      // æ ‡å‡†æ ¼å¼: <text start="12.34" dur="2.5">Hello world</text>
      /<text start="([^"]+)"(?:\s+dur="([^"]+)")?>([^<]*)<\/text>/g,
      // srv3 æ ¼å¼ (æ¯«ç§’): <p t="12340" d="2500">Hello world</p>
      /<p t="([^"]+)"(?:\s+d="([^"]+)")?>([^<]*)<\/p>/g,
      // åŒ…å«æ›´å¤šå±æ€§çš„æ ¼å¼
      /<text[^>]+start="([^"]+)"[^>]*(?:dur="([^"]+)")?[^>]*>([^<]*)<\/text>/g,
      // srv1 æ ¼å¼ with t/d attributes
      /<text[^>]*t="([^"]+)"[^>]*(?:d="([^"]+)")?[^>]*>([^<]*)<\/text>/g,
      // ä¸€ä¸ªæ›´çµæ´»çš„"æœ€ç»ˆé˜²çº¿"æ¨¡å¼ï¼ŒåŒ¹é… text æˆ– p æ ‡ç­¾
      /<(?:text|p)[^>]*(?:start|t)="([^"]+)"[^>]*(?:(?:dur|d)="([^"]+)")?[^>]*>([^<]*)<\/(?:text|p)>/g
    ];

    let matchCount = 0;

    // ä¾æ¬¡å°è¯•æ¯ä¸ªæ­£åˆ™è¡¨è¾¾å¼ï¼Œç›´åˆ°æˆåŠŸè§£æå‡ºå†…å®¹
    for (const textRegex of textPatterns) {
      console.log('[PureSubs] Trying pattern:', textRegex);
      textRegex.lastIndex = 0; // é‡ç½®æ­£åˆ™çŠ¶æ€

      let match;
      while ((match = textRegex.exec(xmlContent)) !== null) {
        matchCount++;
        let start = parseFloat(match[1]);
        let duration = match[2] ? parseFloat(match[2]) : 2.0; // é»˜è®¤2ç§’æ—¶é•¿
        const rawText = match[3];

        // srv3æ ¼å¼ä½¿ç”¨æ¯«ç§’ï¼Œéœ€è¦è½¬æ¢
        if (start > 10000) { // å¦‚æœå¼€å§‹æ—¶é—´å¤§äº10000ï¼ŒåŸºæœ¬å¯ä»¥æ–­å®šæ˜¯æ¯«ç§’
          start /= 1000;
          if (duration > 0) {
            duration /= 1000;
          }
        }

        const text = cleanSubtitleText(rawText);

        if (matchCount <= 5) {
          console.log(`[PureSubs] Match ${matchCount}:`, { start, duration, rawText, cleanedText: text });
        }

        if (text.trim()) {
          entries.push({
            start: start,
            end: start + duration,
            text: text
          });
        }
      }

      // å¦‚æœå½“å‰æ­£åˆ™è¡¨è¾¾å¼å·²ç»æ‰¾åˆ°äº†åŒ¹é…é¡¹ï¼Œå°±æ— éœ€å°è¯•ä¸‹ä¸€ä¸ªäº†
      if (matchCount > 0) {
        console.log(`[PureSubs] Successfully used pattern: ${textRegex}, found ${matchCount} matches`);
        break;
      }
    }

    // å¦‚æœXMLè§£æå¤±è´¥ï¼Œå°è¯•ä½œä¸ºçº¯æ–‡æœ¬å¤„ç†
    if (matchCount === 0) {
      console.log('[PureSubs] XML patterns failed, trying plain text parsing...');
      return parseSubtitleText(xmlContent);
    }

    console.log(`[PureSubs] Found ${matchCount} total matches, parsed ${entries.length} valid entries`);

    // ç¡®ä¿æŒ‰å¼€å§‹æ—¶é—´æ’åº
    const sortedEntries = entries.sort((a, b) => a.start - b.start);
    console.log('[PureSubs] First 3 parsed entries:', sortedEntries.slice(0, 3));
    return sortedEntries;
  } catch (error) {
    console.error('[PureSubs] Failed to parse subtitle XML:', error);
    throw new Error(`Failed to parse subtitle XML: ${error}`);
  }
}

/**
 * Clean subtitle text by removing HTML tags and fixing encoding
 */
export function cleanSubtitleText(text: string): string {
  if (!text) return '';

  return text
    // Remove HTML tags first (before decoding entities that might contain < >)
    .replace(/<[^>]*>/g, '')
    // Decode common HTML entities
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&#x27;/g, "'")
    .replace(/&#x2F;/g, '/')
    // Decode numeric entities
    .replace(/&#(\d+);/g, (match, num) => String.fromCharCode(parseInt(num, 10)))
    .replace(/&#x([a-fA-F0-9]+);/g, (match, hex) => String.fromCharCode(parseInt(hex, 16)))
    // Clean up extra whitespace
    .replace(/\s+/g, ' ')
    .trim();
}

/**
 * Convert subtitle entries to SRT format
 */
export function convertToSRT(entries: SubtitleEntry[]): string {
  console.log(`[PureSubs] Converting ${entries?.length || 0} entries to SRT format`);
  
  if (!entries || entries.length === 0) {
    console.warn('[PureSubs] No entries to convert to SRT');
    return '';
  }
  
  const srtContent = entries
    .map((entry, index) => {
      const startTime = formatSRTTimestamp(entry.start);
      const endTime = formatSRTTimestamp(entry.end);
      
      const srtBlock = [
        (index + 1).toString(),
        `${startTime} --> ${endTime}`,
        entry.text,
        ''
      ].join('\n');
      
      if (index < 3) {
        console.log(`[PureSubs] SRT block ${index + 1}:`, srtBlock);
      }
      
      return srtBlock;
    })
    .join('\n');
    
  console.log(`[PureSubs] Generated SRT content length: ${srtContent.length}`);
  return srtContent;
}

/**
 * Convert subtitle entries to plain text format
 */
export function convertToTXT(entries: SubtitleEntry[], separator: string = '\n'): string {
  console.log(`[PureSubs] Converting ${entries?.length || 0} entries to TXT format`);
  
  if (!entries || entries.length === 0) {
    console.warn('[PureSubs] No entries to convert to TXT');
    return '';
  }
  
  const txtContent = entries.map(entry => entry.text.trim()).join(separator);
  console.log(`[PureSubs] Generated TXT content length: ${txtContent.length}`);
  return txtContent;
}

/**
 * Format time in seconds to SRT timestamp format (HH:MM:SS,mmm)
 */
export function formatSRTTimestamp(seconds: number): string {
  // Handle negative values by clamping to 0
  if (seconds < 0) {
    seconds = 0;
  }
  
  // Round to 3 decimal places to avoid floating point precision issues
  const roundedSeconds = Math.round(seconds * 1000) / 1000;
  
  const hours = Math.floor(roundedSeconds / 3600);
  const minutes = Math.floor((roundedSeconds % 3600) / 60);
  const secs = Math.floor(roundedSeconds % 60);
  const milliseconds = Math.round((roundedSeconds % 1) * 1000);
  
  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${milliseconds.toString().padStart(3, '0')}`;
}

/**
 * Select the best subtitle based on smart priority logic
 * Priority: ä¸­æ–‡ (zh-Hans, zh-CN, zh) -> è‹±æ–‡ (en) -> å…¶ä»–è¯­è¨€
 */
export function selectBestSubtitle(availableSubtitles: SubtitleTrack[]): SubtitleTrack | null {
  if (!availableSubtitles || availableSubtitles.length === 0) {
    return null;
  }

  // ä¼˜å…ˆçº§å®šä¹‰ï¼šä¸­æ–‡å˜ä½“
  const chineseLanguages = ['zh-Hans', 'zh-CN', 'zh', 'zh-TW', 'zh-HK'];
  const englishLanguages = ['en', 'en-US', 'en-GB'];

  // Step 1: æŸ¥æ‰¾ä¸­æ–‡å­—å¹• (ä¼˜å…ˆäººå·¥å­—å¹•)
  for (const lang of chineseLanguages) {
    // é¦–å…ˆæŸ¥æ‰¾äººå·¥ä¸­æ–‡å­—å¹•
    const manualChinese = availableSubtitles.find(sub => 
      sub.language === lang && !sub.isAutoGenerated
    );
    if (manualChinese) {
      console.log('[PureSubs] Selected manual Chinese subtitles:', lang);
      return manualChinese;
    }
  }

  // Step 2: æŸ¥æ‰¾è‡ªåŠ¨ç”Ÿæˆçš„ä¸­æ–‡å­—å¹•
  for (const lang of chineseLanguages) {
    const autoChinese = availableSubtitles.find(sub => 
      sub.language === lang && sub.isAutoGenerated
    );
    if (autoChinese) {
      console.log('[PureSubs] Selected auto-generated Chinese subtitles:', lang);
      return autoChinese;
    }
  }

  // Step 3: æŸ¥æ‰¾è‹±æ–‡å­—å¹• (ä¼˜å…ˆäººå·¥å­—å¹•)
  for (const lang of englishLanguages) {
    const manualEnglish = availableSubtitles.find(sub => 
      sub.language === lang && !sub.isAutoGenerated
    );
    if (manualEnglish) {
      console.log('[PureSubs] Selected manual English subtitles:', lang);
      return manualEnglish;
    }
  }

  // Step 4: æŸ¥æ‰¾è‡ªåŠ¨ç”Ÿæˆçš„è‹±æ–‡å­—å¹•
  for (const lang of englishLanguages) {
    const autoEnglish = availableSubtitles.find(sub => 
      sub.language === lang && sub.isAutoGenerated
    );
    if (autoEnglish) {
      console.log('[PureSubs] Selected auto-generated English subtitles:', lang);
      return autoEnglish;
    }
  }

  // Step 5: å¦‚æœæ²¡æœ‰ä¸­æ–‡å’Œè‹±æ–‡ï¼Œè¿”å›ç¬¬ä¸€ä¸ªå¯ç”¨çš„å­—å¹•
  const fallback = availableSubtitles[0];
  console.log('[PureSubs] Using fallback subtitle:', fallback.language);
  return fallback;
}

/**
 * Main function to extract YouTube data from current page
 * This works in Chrome extension context without external dependencies
 */
export async function getYouTubeDataFromPage(options: ExtractOptions = {}): Promise<YouTubeVideoData> {
  try {
    // Step 1: Extract ytInitialPlayerResponse from current page
    const playerResponse = extractPlayerResponseFromPage();
    
    // Step 2: Extract video metadata
    const metadata = extractVideoMetadata(playerResponse);
    
    // Step 3: Extract available subtitle tracks
    const availableSubtitles = extractSubtitleTracks(playerResponse);
    
    // Step 4: Extract subtitles if requested
    let subtitles;
    if (options.extractSubtitles && availableSubtitles.length > 0) {
      console.log('[PureSubs] ğŸ¯ Extracting subtitles using 2025 spy injection method...');
      
      // é€‰æ‹©æœ€ä½³å­—å¹•
      let selectedSubtitle = null;
      if (options.subtitleLanguage) {
        selectedSubtitle = availableSubtitles.find(track => track.language === options.subtitleLanguage);
      }
      if (!selectedSubtitle) {
        selectedSubtitle = selectBestSubtitle(availableSubtitles);
      }
      
      if (selectedSubtitle) {
        console.log('[PureSubs] ğŸ­ Selected subtitle track:', selectedSubtitle);
        
        try {
          // ğŸ•µï¸ æ–°ç­–ç•¥ï¼šä½¿ç”¨æ³¨å…¥çš„é—´è°è„šæœ¬æ‹¦æˆªæ•°æ®
          const videoId = extractVideoIdFromCurrentURL();
          
          // é¦–å…ˆæ£€æŸ¥æ˜¯å¦å·²ç»æœ‰æ‹¦æˆªåˆ°çš„æ•°æ®
          let spyData = getInterceptedSubtitleData(videoId, selectedSubtitle.language);
          
          if (!spyData) {
            console.log('[PureSubs] ğŸ” No spy data found yet, triggering subtitle loading...');
            
            // æ£€æŸ¥é—´è°è„šæœ¬çŠ¶æ€
            await checkSpyStatus();
            
            // è§¦å‘å­—å¹•åŠ è½½ï¼ˆæ¨¡æ‹Ÿç”¨æˆ·æ“ä½œï¼‰
            await triggerSubtitleLoading();
            
            // ç­‰å¾…é—´è°æ‹¦æˆªæ•°æ®
            console.log('[PureSubs] â³ Waiting for spy to intercept subtitle data...');
            spyData = await waitForSpyData(videoId, selectedSubtitle.language, 5000);
          }
          
          if (spyData && spyData.content) {
            console.log('[PureSubs] ğŸ‰ Using intercepted spy data!');
            console.log(`[PureSubs] ğŸ“Š Data format: ${spyData.format}, length: ${spyData.content.length}`);
            
            // è§£æä¸åŒæ ¼å¼çš„å­—å¹•æ•°æ®
            let entries: SubtitleEntry[] = [];
            
            if (spyData.format === 'json3' || spyData.content.includes('"events"')) {
              // JSON3æ ¼å¼
              entries = parseJSON3Subtitles(spyData.content);
            } else if (spyData.content.includes('<transcript>') || spyData.content.includes('<text')) {
              // XMLæ ¼å¼
              entries = parseSubtitleXML(spyData.content);
            } else {
              // å°è¯•ä½œä¸ºJSONè§£æ
              try {
                const jsonData = JSON.parse(spyData.content);
                if (jsonData.events) {
                  entries = parseJSON3Subtitles(spyData.content);
                }
              } catch {
                console.warn('[PureSubs] âš ï¸ Unknown subtitle format, attempting plain text parsing');
                entries = parseSubtitleTextFallback(spyData.content);
              }
            }
            
            if (entries.length > 0) {
              console.log(`[PureSubs] âœ… Successfully parsed ${entries.length} subtitle entries`);
              
              subtitles = {
                srt: convertToSRT(entries),
                txt: convertToTXT(entries),
                entries: entries
              };
            } else {
              throw new Error('Failed to parse intercepted subtitle data');
            }
            
          } else {
            throw new Error('No subtitle data intercepted by spy');
          }
          
        } catch (spyError: any) {
          console.error('[PureSubs] ğŸš¨ Spy interception method failed:', spyError);
          
          // ğŸš« ç§»é™¤äº†ä¼šå¯¼è‡´ ChunkLoadError çš„å¤‡é€‰æ–¹æ¡ˆ
          // ç›´æ¥æä¾›ç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯ï¼Œè€Œä¸æ˜¯å°è¯•å…¶ä»–å¯èƒ½å¤±è´¥çš„æ–¹æ³•
          console.log('[PureSubs] â„¹ï¸ Primary spy method failed, providing user guidance...');
          
          const errorMessage = `ğŸš¨ å­—å¹•è·å–å¤±è´¥

è§†é¢‘: ${metadata.title}

å¯èƒ½çš„åŸå› ï¼š
- YouTube æ›´æ–°äº†é¡µé¢ç»“æ„
- å­—å¹•æ•°æ®å°šæœªåŠ è½½å®Œæˆ
- ç½‘ç»œè¿æ¥é—®é¢˜

å»ºè®®è§£å†³æ–¹æ¡ˆï¼š
1. åˆ·æ–°é¡µé¢åé‡è¯•
2. ç¡®ä¿è§†é¢‘æ­£åœ¨æ’­æ”¾
3. åœ¨YouTubeæ’­æ”¾å™¨ä¸­æ‰‹åŠ¨å¼€å¯å­—å¹•
4. ç¨ç­‰ç‰‡åˆ»åå†æ¬¡å°è¯•ä¸‹è½½

PureSubs Team - 2025`;

          subtitles = {
            srt: `1\n00:00:00,000 --> 00:00:15,000\n${errorMessage}\n\n`,
            txt: errorMessage,
            entries: [{
              start: 0,
              end: 15,
              text: errorMessage
            }]
          };
        }
      } else {
        console.log('[PureSubs] âŒ No suitable subtitle track found');
        const noSubsMessage = `ğŸ“º è¯¥è§†é¢‘æš‚æ— å¯ç”¨å­—å¹•

è§†é¢‘: ${metadata.title}

æ£€æµ‹ç»“æœï¼š
- å¯ç”¨å­—å¹•è½¨é“ï¼š${availableSubtitles.length}ä¸ª
- æ”¯æŒçš„è¯­è¨€ï¼š${availableSubtitles.map(track => `${track.name} (${track.language})`).join(', ') || 'æ— '}
- é—´è°è„šæœ¬çŠ¶æ€ï¼šå·²æ³¨å…¥

æ­¤è§†é¢‘å¯èƒ½ï¼š
1. æ²¡æœ‰ä¸Šä¼ å­—å¹•æ–‡ä»¶
2. å­—å¹•ä»…å¯¹ç‰¹å®šåœ°åŒºå¼€æ”¾  
3. éœ€è¦åœ¨YouTubeæ’­æ”¾å™¨ä¸­æ‰‹åŠ¨å¼€å¯

å»ºè®®åœ¨YouTubeæ’­æ”¾å™¨è®¾ç½®ä¸­æ£€æŸ¥å­—å¹•é€‰é¡¹ã€‚

PureSubs Team`;

        subtitles = {
          srt: `1\n00:00:00,000 --> 00:00:08,000\n${noSubsMessage}\n\n`,
          txt: noSubsMessage,
          entries: [{
            start: 0,
            end: 8,
            text: noSubsMessage
          }]
        };
      }
    }
    
    return {
      title: metadata.title,
      description: metadata.description,
      availableSubtitles,
      subtitles
    };
  } catch (error) {
    console.error('[PureSubs] ğŸ’¥ Failed to extract YouTube data:', error);
    throw new Error(`Failed to extract YouTube data: ${error}`);
  }
}

/**
 * æ£€æŸ¥é—´è°è„šæœ¬çŠ¶æ€
 */
async function checkSpyStatus(): Promise<void> {
  return new Promise((resolve) => {
    const timeout = setTimeout(() => {
      console.log('[PureSubs] â° Spy status check timeout');
      resolve();
    }, 1000);
    
    const handleMessage = (event: MessageEvent) => {
      if (event.data?.type === 'PURESUBS_SPY_STATUS') {
        console.log('[PureSubs] ğŸ“Š Spy status received:', event.data.data);
        window.removeEventListener('message', handleMessage);
        clearTimeout(timeout);
        resolve();
      }
    };
    
    window.addEventListener('message', handleMessage);
    
    // è¯·æ±‚é—´è°çŠ¶æ€
    window.postMessage({ type: 'PURESUBS_REQUEST_STATUS' }, '*');
  });
}

/**
 * ç­‰å¾…é—´è°æ‹¦æˆªæ•°æ® - ä½¿ç”¨ç»Ÿä¸€çš„Promiseå”¤é†’æœºåˆ¶
 */
async function waitForSpyData(videoId: string, language: string, timeoutMs: number = 5000): Promise<any> {
  // ğŸ¯ ä½¿ç”¨content scriptçš„ç»Ÿä¸€Promiseæœºåˆ¶
  const contentScript = (window as any).puresubsContentScript;
  
  if (contentScript && contentScript.waitForSpyData) {
    console.log('[PureSubs] ğŸ”„ Using content script Promise mechanism for waiting...');
    try {
      return await contentScript.waitForSpyData(videoId, language, timeoutMs);
    } catch (error) {
      console.log('[PureSubs] â° Content script waiting timeout:', String(error));
      return null;
    }
  }
  
  // ğŸ”™ å›é€€åˆ°åŸæœ‰é€»è¾‘ï¼ˆå¦‚æœcontent scriptæ¥å£ä¸å¯ç”¨ï¼‰
  console.log('[PureSubs] âš ï¸ Content script interface not available, using fallback...');
  return new Promise((resolve) => {
    const timeout = setTimeout(() => {
      console.log('[PureSubs] â° Waiting for spy data timeout');
      resolve(null);
    }, timeoutMs);
    
    const handleMessage = (event: MessageEvent) => {
      if (event.data?.type === 'PURESUBS_SUBTITLE_INTERCEPTED') {
        const data = event.data.data;
        if (data.videoId === videoId && (data.language === language || !language)) {
          console.log('[PureSubs] ğŸ¯ Got matching spy data!');
          window.removeEventListener('message', handleMessage);
          clearTimeout(timeout);
          resolve(data);
        }
      }
    };
    
    window.addEventListener('message', handleMessage);
  });
}

/**
 * ç®€å•çš„æ–‡æœ¬è§£æï¼ˆä½œä¸ºæœ€åå›é€€ï¼‰
 */
function parseSubtitleTextFallback(content: string): SubtitleEntry[] {
  const lines = content.split('\n').filter(line => line.trim());
  const entries: SubtitleEntry[] = [];
  
  lines.forEach((line, index) => {
    if (line.trim()) {
      entries.push({
        start: index * 3,
        end: (index + 1) * 3,
        text: line.trim()
      });
    }
  });
  
  return entries;
}

/**
 * ä»å½“å‰URLæå–è§†é¢‘ID
 */
function extractVideoIdFromCurrentURL(): string {
  const urlParams = new URLSearchParams(window.location.search);
  return urlParams.get('v') || '';
}

/**
 * è§¦å‘å­—å¹•åŠ è½½ï¼ˆæ¨¡æ‹Ÿç”¨æˆ·æ“ä½œï¼‰
 */
async function triggerSubtitleLoading(): Promise<void> {
  try {
    console.log('[PureSubs] Attempting to trigger subtitle loading...');
    
    // æŸ¥æ‰¾å­—å¹•æŒ‰é’®
    const captionButton = document.querySelector('[data-title-no-tooltip="Subtitles/closed captions unavailable"], [data-title-no-tooltip*="subtitle"], .ytp-subtitles-button, .ytp-cc-button');
    
    if (captionButton && captionButton instanceof HTMLElement) {
      console.log('[PureSubs] Found caption button, attempting to click...');
      captionButton.click();
      
      // ç­‰å¾…ä¸€ä¸‹è®©èœå•åŠ è½½
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå­—å¹•é€‰é¡¹
      const subtitleOption = document.querySelector('.ytp-menuitem[role="menuitemradio"]');
      if (subtitleOption && subtitleOption instanceof HTMLElement) {
        console.log('[PureSubs] Found subtitle option, clicking...');
        subtitleOption.click();
      }
    } else {
      console.log('[PureSubs] Caption button not found, subtitle loading may not be triggered');
    }
  } catch (error) {
    console.error('[PureSubs] Error triggering subtitle loading:', error);
  }
}