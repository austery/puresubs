/**
 * Tests for browser-engine module
 */
import { 
  extractPlayerResponseFromPage,
  extractVideoMetadata,
  extractSubtitleTracks,
  selectBestSubtitle,
  convertToSRT,
  convertToTXT,
  formatSRTTimestamp,
  cleanSubtitleText,
  parseSubtitleXML,
  type SubtitleEntry,
  type SubtitleTrack
} from '../browser-engine';

// Mock data based on real YouTube responses
const mockPlayerResponse = {
  videoDetails: {
    videoId: 'dQw4w9WgXcQ',
    title: 'Test Video Title',
    shortDescription: 'Test video description'
  },
  captions: {
    playerCaptionsTracklistRenderer: {
      captionTracks: [
        {
          baseUrl: 'https://www.youtube.com/api/timedtext?v=dQw4w9WgXcQ&lang=en',
          name: { simpleText: 'English' },
          languageCode: 'en',
          kind: 'asr'
        },
        {
          baseUrl: 'https://www.youtube.com/api/timedtext?v=dQw4w9WgXcQ&lang=zh',
          name: { simpleText: '中文 (中国)' },
          languageCode: 'zh-Hans'
        }
      ]
    }
  }
};

const mockSubtitleEntries: SubtitleEntry[] = [
  { start: 0, end: 3, text: 'Hello world' },
  { start: 3.5, end: 6, text: 'This is a test' },
  { start: 7, end: 10, text: 'Final subtitle' }
];

describe('browser-engine', () => {
  beforeEach(() => {
    // Mock DOM
    document.body.innerHTML = '';
    Object.defineProperty(window, 'location', {
      value: {
        href: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ',
        pathname: '/watch'
      },
      writable: true
    });
  });

  describe('extractVideoMetadata', () => {
    it('should extract basic video metadata', () => {
      const metadata = extractVideoMetadata(mockPlayerResponse);
      
      expect(metadata).toEqual({
        title: 'Test Video Title',
        description: 'Test video description'
      });
    });

    it('should handle missing metadata gracefully', () => {
      const emptyResponse = {};
      const metadata = extractVideoMetadata(emptyResponse);
      
      expect(metadata).toEqual({
        title: 'Untitled',
        description: ''
      });
    });
  });

  describe('extractSubtitleTracks', () => {
    it('should extract subtitle tracks from player response', () => {
      const tracks = extractSubtitleTracks(mockPlayerResponse);
      
      expect(tracks).toHaveLength(2);
      expect(tracks[0]).toEqual({
        language: 'en',
        name: 'English',
        baseUrl: 'https://www.youtube.com/api/timedtext?v=dQw4w9WgXcQ&lang=en',
        isAutoGenerated: true
      });
      expect(tracks[1]).toEqual({
        language: 'zh-Hans',
        name: '中文 (中国)',
        baseUrl: 'https://www.youtube.com/api/timedtext?v=dQw4w9WgXcQ&lang=zh',
        isAutoGenerated: false
      });
    });

    it('should return empty array when no captions available', () => {
      const responseWithoutCaptions = { videoDetails: {} };
      const tracks = extractSubtitleTracks(responseWithoutCaptions);
      
      expect(tracks).toEqual([]);
    });
  });

  describe('selectBestSubtitle', () => {
    const subtitleTracks: SubtitleTrack[] = [
      { language: 'en', name: 'English', baseUrl: 'test-en', isAutoGenerated: true },
      { language: 'zh-Hans', name: '中文', baseUrl: 'test-zh', isAutoGenerated: false },
      { language: 'ja', name: '日本語', baseUrl: 'test-ja', isAutoGenerated: false }
    ];

    it('should prefer Chinese subtitles when available', () => {
      const selected = selectBestSubtitle(subtitleTracks);
      expect(selected?.language).toBe('zh-Hans');
    });

    it('should fallback to English when Chinese not available', () => {
      const englishOnlyTracks = [subtitleTracks[0], subtitleTracks[2]];
      const selected = selectBestSubtitle(englishOnlyTracks);
      expect(selected?.language).toBe('en');
    });

    it('should return first available track when neither Chinese nor English available', () => {
      const japaneseOnlyTracks = [subtitleTracks[2]];
      const selected = selectBestSubtitle(japaneseOnlyTracks);
      expect(selected?.language).toBe('ja');
    });

    it('should return null for empty track list', () => {
      const selected = selectBestSubtitle([]);
      expect(selected).toBeNull();
    });
  });

  describe('extractPlayerResponseFromPage', () => {
    beforeEach(() => {
      // Clear any existing script tags and DOM content
      document.head.innerHTML = '';
      document.body.innerHTML = '';
    });

    it('should extract player response from script tags', () => {
      // Setup: Add a script with valid ytInitialPlayerResponse
      const script = document.createElement('script');
      script.innerHTML = `
        var ytInitialPlayerResponse = ${JSON.stringify({
          videoDetails: {
            videoId: 'dQw4w9WgXcQ',
            title: 'Test Video Title',
            shortDescription: 'Test video description'
          },
          captions: {
            playerCaptionsTracklistRenderer: {
              captionTracks: [
                {
                  baseUrl: 'https://www.youtube.com/api/timedtext?v=dQw4w9WgXcQ&lang=en',
                  name: { simpleText: 'English' },
                  languageCode: 'en',
                  kind: 'asr'
                },
                {
                  baseUrl: 'https://www.youtube.com/api/timedtext?v=dQw4w9WgXcQ&lang=zh',
                  name: { simpleText: '中文 (中国)' },
                  languageCode: 'zh-Hans'
                }
              ]
            }
          }
        })};
      `;
      document.head.appendChild(script);

      const result = extractPlayerResponseFromPage();
      expect(result.videoDetails.videoId).toBe('dQw4w9WgXcQ');
      expect(result.videoDetails.title).toBe('Test Video Title');
      expect(result.captions.playerCaptionsTracklistRenderer.captionTracks).toHaveLength(2);
    });

    it('should return empty object when no player response found', () => {
      // No script tags with player response
      const result = extractPlayerResponseFromPage();
      expect(result).toEqual({});
    });

    it('should handle malformed JSON gracefully', () => {
      // Don't add malformed script that would cause syntax error
      // Instead test empty result when no valid JSON is found
      const script = document.createElement('script');
      script.innerHTML = 'console.log("no player response here");';
      document.head.appendChild(script);

      const result = extractPlayerResponseFromPage();
      expect(result).toEqual({});
    });
  });  describe('convertToSRT', () => {
    it('should convert subtitle entries to SRT format', () => {
      const srt = convertToSRT(mockSubtitleEntries);
      
      expect(srt).toContain('1\n00:00:00,000 --> 00:00:03,000\nHello world');
      expect(srt).toContain('2\n00:00:03,500 --> 00:00:06,000\nThis is a test');
      expect(srt).toContain('3\n00:00:07,000 --> 00:00:10,000\nFinal subtitle');
    });

    it('should handle empty entries array', () => {
      const srt = convertToSRT([]);
      expect(srt).toBe('');
    });
  });

  describe('convertToTXT', () => {
    it('should convert subtitle entries to plain text', () => {
      const txt = convertToTXT(mockSubtitleEntries);
      
      expect(txt).toBe('Hello world\nThis is a test\nFinal subtitle');
    });

    it('should use custom separator', () => {
      const txt = convertToTXT(mockSubtitleEntries, ' | ');
      
      expect(txt).toBe('Hello world | This is a test | Final subtitle');
    });

    it('should handle empty entries array', () => {
      const txt = convertToTXT([]);
      expect(txt).toBe('');
    });
  });

  describe('formatSRTTimestamp', () => {
    it('should format seconds to SRT timestamp format', () => {
      expect(formatSRTTimestamp(0)).toBe('00:00:00,000');
      expect(formatSRTTimestamp(65.5)).toBe('00:01:05,500');
      expect(formatSRTTimestamp(3661.123)).toBe('01:01:01,123');
    });

    it('should handle negative values', () => {
      expect(formatSRTTimestamp(-5)).toBe('00:00:00,000');
    });
  });

  describe('cleanSubtitleText', () => {
    it('should remove HTML tags', () => {
      expect(cleanSubtitleText('<b>Bold text</b>')).toBe('Bold text');
      expect(cleanSubtitleText('<i>Italic</i> and <u>underlined</u>')).toBe('Italic and underlined');
    });

    it('should decode HTML entities', () => {
      expect(cleanSubtitleText('&amp;&lt;&gt;&quot;&#39;')).toBe('&<>"\'');
    });

    it('should trim whitespace', () => {
      expect(cleanSubtitleText('  trimmed  ')).toBe('trimmed');
    });

    it('should handle empty or null input', () => {
      expect(cleanSubtitleText('')).toBe('');
      expect(cleanSubtitleText('   ')).toBe('');
    });
  });

  describe('parseSubtitleXML', () => {
    const mockXML = `
      <transcript>
        <text start="0" dur="3">Hello world</text>
        <text start="3.5" dur="2.5">This is a test</text>
        <text start="7" dur="3">Final subtitle</text>
      </transcript>
    `;

    it('should parse XML subtitle content', () => {
      const entries = parseSubtitleXML(mockXML);
      
      expect(entries).toHaveLength(3);
      expect(entries[0]).toEqual({ start: 0, end: 3, text: 'Hello world' });
      expect(entries[1]).toEqual({ start: 3.5, end: 6, text: 'This is a test' });
      expect(entries[2]).toEqual({ start: 7, end: 10, text: 'Final subtitle' });
    });

    it('should handle malformed XML gracefully', () => {
      const entries = parseSubtitleXML('<invalid xml>');
      expect(entries).toEqual([]);
    });

    it('should handle empty XML', () => {
      const entries = parseSubtitleXML('');
      expect(entries).toEqual([]);
    });
  });
});
