/**
 * PureSubs Core Engine
 * 
 * This module provides the core functionality to extract metadata and subtitles
 * from YouTube videos. It's designed to be environment-agnostic and can run
 * in both browser and Node.js environments.
 * 
 * @author PureSubs Team
 * @version 1.0.0
 */

// Export all types for better type safety across the project
export * from './types';

export interface SubtitleTrack {
  /** Language code (e.g., 'en', 'zh-Hans') */
  language: string;
  /** Human readable language name */
  name: string;
  /** Whether this is auto-generated or manual */
  isAutoGenerated: boolean;
  /** URL to the subtitle XML file */
  baseUrl: string;
}

export interface SubtitleEntry {
  /** Start time in seconds */
  start: number;
  /** End time in seconds */
  end: number;
  /** Subtitle text content */
  text: string;
}

export interface YouTubeVideoData {
  /** Video title */
  title: string;
  /** Video description */
  description: string;
  /** Available subtitle tracks */
  availableSubtitles: SubtitleTrack[];
  /** Extracted subtitles in different formats */
  subtitles?: {
    /** SRT format with timestamps */
    srt: string;
    /** Plain text format */
    txt: string;
    /** Raw subtitle entries */
    entries: SubtitleEntry[];
  };
}

export interface ExtractOptions {
  /** Preferred language codes in order of preference */
  preferredLanguages?: string[];
  /** Whether to include auto-generated subtitles */
  includeAutoGenerated?: boolean;
  /** Whether to extract subtitle content (default: false) */
  extractSubtitles?: boolean;
  /** Target language for subtitle extraction */
  subtitleLanguage?: string;
}

/**
 * Main function to extract YouTube video data
 * 
 * @param url - YouTube video URL
 * @param options - Extraction options
 * @returns Promise containing video data
 */
export async function getYouTubeData(
  url: string,
  options: ExtractOptions = {}
): Promise<YouTubeVideoData> {
  try {
    // Step 1: Fetch YouTube page HTML
    const html = await fetchYouTubePageHTML(url);
    
    // Step 2: Extract ytInitialPlayerResponse
    const playerResponse = extractPlayerResponse(html);
    
    // Step 3: Extract video metadata
    const metadata = extractVideoMetadata(playerResponse);
    
    // Step 4: Extract available subtitle tracks
    const availableSubtitles = extractSubtitleTracks(playerResponse);
    
    // Step 5: Extract subtitles if requested
    let subtitles;
    if (options.extractSubtitles && availableSubtitles.length > 0) {
      subtitles = await extractSubtitleContent(availableSubtitles, options);
    }
    
    return {
      title: metadata.title,
      description: metadata.description,
      availableSubtitles,
      subtitles
    };
  } catch (error) {
    throw new Error(`Failed to extract YouTube data: ${error}`);
  }
}

/**
 * Extract subtitle tracks from ytInitialPlayerResponse
 * 
 * @param playerResponse - The parsed ytInitialPlayerResponse object
 * @returns Array of available subtitle tracks
 */
export function extractSubtitleTracks(playerResponse: any): SubtitleTrack[] {
  // Implementation is in extractor.ts
  return extractSubtitleTracksFromExtractor(playerResponse);
}

/**
 * Parse subtitle XML content into structured data
 * 
 * @param xmlContent - Raw XML subtitle content
 * @returns Array of subtitle entries
 */
export function parseSubtitleXML(xmlContent: string): SubtitleEntry[] {
  // Implementation is in parser.ts
  return parseSubtitleXMLFromParser(xmlContent);
}

/**
 * Convert subtitle entries to SRT format
 * 
 * @param entries - Array of subtitle entries
 * @returns SRT formatted string
 */
export function convertToSRT(entries: SubtitleEntry[]): string {
  // Implementation is in parser.ts
  return convertToSRTFromParser(entries);
}

/**
 * Convert subtitle entries to plain text format
 * 
 * @param entries - Array of subtitle entries
 * @returns Plain text string
 */
export function convertToTXT(entries: SubtitleEntry[]): string {
  // Implementation is in parser.ts
  return convertToTXTFromParser(entries);
}

// Import functions from modules
import { 
  fetchYouTubePageHTML,
  extractPlayerResponse,
  extractVideoMetadata,
  extractSubtitleTracks as extractSubtitleTracksFromExtractor,
  fetchSubtitleXML
} from './extractor';
import {
  parseSubtitleXML as parseSubtitleXMLFromParser,
  convertToSRT as convertToSRTFromParser,
  convertToTXT as convertToTXTFromParser
} from './parser';

/**
 * Extract subtitle content based on options
 */
async function extractSubtitleContent(
  availableSubtitles: SubtitleTrack[],
  options: ExtractOptions
): Promise<{ srt: string; txt: string; entries: SubtitleEntry[] }> {
  // 智能语言选择逻辑：中文 -> 英文 -> 提示
  const preferredLanguages = options.preferredLanguages || ['zh-Hans', 'zh-CN', 'zh', 'en'];
  const targetLanguage = options.subtitleLanguage;
  
  let selectedTrack: SubtitleTrack | null = null;
  
  if (targetLanguage) {
    // 如果指定了目标语言，优先查找
    selectedTrack = availableSubtitles.find(track => track.language === targetLanguage) || null;
  } else {
    // 按偏好语言顺序查找
    for (const lang of preferredLanguages) {
      selectedTrack = availableSubtitles.find(track => 
        track.language === lang || track.language.startsWith(lang)
      ) || null;
      if (selectedTrack) break;
    }
  }
  
  if (!selectedTrack) {
    throw new Error('No suitable subtitles found');
  }
  
  // 获取字幕XML内容
  const xmlContent = await fetchSubtitleXML(selectedTrack.baseUrl);
  
  // 解析为结构化数据
  const entries = parseSubtitleXMLFromParser(xmlContent);
  
  // 转换为不同格式
  const srt = convertToSRTFromParser(entries);
  const txt = convertToTXTFromParser(entries);
  
  return { srt, txt, entries };
}

// Re-export all types and functions
export * from './extractor';
export * from './parser';
export * from './utils';
