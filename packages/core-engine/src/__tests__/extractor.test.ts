import {
  fetchYouTubePageHTML,
  extractPlayerResponse,
  extractSubtitleTracks,
  fetchSubtitleXML,
  isValidYouTubeURL,
  extractVideoId,
  extractVideoMetadata
} from '../extractor';

describe('extractor.ts - Error Handling and Edge Cases', () => {
  const mockedFetch = global.fetch as unknown as jest.Mock;

  beforeEach(() => {
    mockedFetch.mockReset();
  });

  describe('fetchYouTubePageHTML', () => {
    it('throws on invalid YouTube URL', async () => {
      await expect(fetchYouTubePageHTML('https://example.com/foo'))
        .rejects.toThrow('Invalid YouTube URL');
    });

    it('throws on non-OK HTTP status', async () => {
      mockedFetch.mockResolvedValueOnce({ ok: false, status: 500 });
      await expect(
        fetchYouTubePageHTML('https://www.youtube.com/watch?v=abcdefghijk')
      ).rejects.toThrow('HTTP error! status: 500');
    });

    it('wraps network failures with a helpful message', async () => {
      mockedFetch.mockRejectedValueOnce(new Error('network down'));
      await expect(
        fetchYouTubePageHTML('https://www.youtube.com/watch?v=abcdefghijk')
      ).rejects.toThrow('Failed to fetch YouTube page: Error: network down');
    });
  });

  describe('extractPlayerResponse', () => {
    it('parses primary pattern: var ytInitialPlayerResponse = {...};', () => {
      const html = `<!doctype html><html><body>
        <script>var ytInitialPlayerResponse = {"videoDetails": {"title": "T"}};</script>
      </body></html>`;
      const pr = extractPlayerResponse(html);
      expect(pr.videoDetails.title).toBe('T');
    });

    it('parses alternative pattern: "ytInitialPlayerResponse": {...},', () => {
      // Construct a string that matches the alt regex: ytInitialPlayerResponse":\s*(\{.+?\}),"
      const altHtml = 'ytInitialPlayerResponse": {"videoDetails": {"title": "Alt"}},"';
      const pr = extractPlayerResponse(altHtml);
      expect(pr.videoDetails.title).toBe('Alt');
    });
    it('throws when ytInitialPlayerResponse is missing', () => {
      const html = '<html><body><p>No data here</p></body></html>';
      expect(() => extractPlayerResponse(html))
        .toThrow('Could not find ytInitialPlayerResponse in page HTML');
    });

    it('throws when ytInitialPlayerResponse JSON is malformed', () => {
      const html = `<!DOCTYPE html>
        <html><body>
          <script>
            var ytInitialPlayerResponse = {"title": "ok", };
          </script>
        </body></html>`; // trailing comma -> invalid JSON
      expect(() => extractPlayerResponse(html))
        .toThrow(/Failed to parse ytInitialPlayerResponse/);
    });
  });

  describe('extractSubtitleTracks', () => {
    it('returns empty array when captions object is missing', () => {
      const tracks = extractSubtitleTracks({});
      expect(tracks).toEqual([]);
    });

    it('returns empty array when captionTracks is empty', () => {
      const pr = {
        captions: { playerCaptionsTracklistRenderer: { captionTracks: [] } },
      };
      expect(extractSubtitleTracks(pr)).toEqual([]);
    });

    it('maps captionTracks to SubtitleTrack with auto-generated detection', () => {
      const pr = {
        captions: {
          playerCaptionsTracklistRenderer: {
            captionTracks: [
              {
                languageCode: 'en',
                name: { simpleText: 'English (auto-generated)' },
                kind: 'asr',
                baseUrl: 'https://example.com/subs?lang=en',
              },
            ],
          },
        },
      };
      const tracks = extractSubtitleTracks(pr);
      expect(tracks).toHaveLength(1);
      expect(tracks[0]).toEqual({
        language: 'en',
        name: 'English (auto-generated)',
        isAutoGenerated: true,
        baseUrl: 'https://example.com/subs?lang=en',
      });
    });

    it('maps using name.runs fallback and unknown language/name defaults', () => {
      const pr = {
        captions: {
          playerCaptionsTracklistRenderer: {
            captionTracks: [
              { name: { runs: [{ text: 'Name via runs' }] }, baseUrl: 'u1' },
              { languageCode: undefined, name: {}, baseUrl: 'u2' }
            ]
          }
        }
      };
      const tracks = extractSubtitleTracks(pr);
      expect(tracks[0]).toEqual({
        language: 'unknown',
        name: 'Name via runs',
        isAutoGenerated: false,
        baseUrl: 'u1'
      });
      expect(tracks[1]).toEqual({
        language: 'unknown',
        name: 'Unknown',
        isAutoGenerated: false,
        baseUrl: 'u2'
      });
    });
  });

  describe('fetchSubtitleXML', () => {
    it('throws on non-OK HTTP status', async () => {
      mockedFetch.mockResolvedValueOnce({ ok: false, status: 404 });
      await expect(fetchSubtitleXML('https://subs.example.com/en'))
        .rejects.toThrow('HTTP error! status: 404');
    });

    it('wraps network failures with a helpful message', async () => {
      mockedFetch.mockRejectedValueOnce(new Error('blocked'));
      await expect(fetchSubtitleXML('https://subs.example.com/en'))
        .rejects.toThrow('Failed to fetch subtitle XML: Error: blocked');
    });
  });

  describe('URL helpers', () => {
    it('validates YouTube URLs correctly', () => {
      expect(isValidYouTubeURL('https://www.youtube.com/watch?v=abcdefghijk')).toBe(true);
      expect(isValidYouTubeURL('https://youtu.be/abcdefghijk')).toBe(true);
      expect(isValidYouTubeURL('https://example.com/not-youtube')).toBe(false);
    });

    it('extracts video ID from URLs', () => {
      expect(extractVideoId('https://www.youtube.com/watch?v=abcdefghijk')).toBe('abcdefghijk');
      expect(extractVideoId('https://youtu.be/abcdefghijk')).toBe('abcdefghijk');
      expect(extractVideoId('https://example.com/none')).toBeNull();
    });
  });

  describe('extractVideoMetadata', () => {
    it('returns defaults when fields are missing', () => {
      const meta = extractVideoMetadata({ videoDetails: {} });
      expect(meta.title).toBe('Untitled');
      expect(meta.description).toBe('');
    });

    it('throws when videoDetails missing', () => {
      expect(() => extractVideoMetadata({})).toThrow('No videoDetails found in playerResponse');
    });
  });

  describe('fetchYouTubePageHTML success path', () => {
    it('returns text when response ok', async () => {
      const mockedFetch = global.fetch as unknown as jest.Mock;
      mockedFetch.mockResolvedValueOnce({ ok: true, status: 200, text: () => Promise.resolve('<html/>') });
      const html = await fetchYouTubePageHTML('https://www.youtube.com/watch?v=abcdefghijk');
      expect(html).toContain('<html');
    });
  });
});
