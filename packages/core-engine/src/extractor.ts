/**
 * YouTube Data Extractor
 * 
 * This module handles the extraction of YouTube video data including
 * metadata and subtitle information from video URLs.
 */

import { SubtitleTrack } from './index';

/**
 * Fetch YouTube page HTML content
 * 
 * @param url - YouTube video URL
 * @returns Promise containing the HTML content
 */
export async function fetchYouTubePageHTML(url: string): Promise<string> {
  // Validate URL
  if (!isValidYouTubeURL(url)) {
    throw new Error('Invalid YouTube URL');
  }

  try {
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
      }
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    return await response.text();
  } catch (error) {
    throw new Error(`Failed to fetch YouTube page: ${error}`);
  }
}

/**
 * Extract ytInitialPlayerResponse from HTML content
 * 
 * @param html - YouTube page HTML content
 * @returns Parsed ytInitialPlayerResponse object
 */
export function extractPlayerResponse(html: string): any {
  try {
    // Pattern to match ytInitialPlayerResponse
    const playerResponseMatch = html.match(/var ytInitialPlayerResponse\s*=\s*(\{.+?\});/);
    
    if (!playerResponseMatch) {
      // Try alternative patterns
      const altMatch = html.match(/ytInitialPlayerResponse":\s*(\{.+?\}),"/);
      if (!altMatch) {
        throw new Error('Could not find ytInitialPlayerResponse in page HTML');
      }
      return JSON.parse(altMatch[1]);
    }
    
    return JSON.parse(playerResponseMatch[1]);
  } catch (error) {
    throw new Error(`Failed to parse ytInitialPlayerResponse: ${error}`);
  }
}

/**
 * Extract video metadata from player response
 * 
 * @param playerResponse - The parsed ytInitialPlayerResponse object
 * @returns Object containing title and description
 */
export function extractVideoMetadata(playerResponse: any): {
  title: string;
  description: string;
} {
  try {
    const videoDetails = playerResponse.videoDetails;
    
    if (!videoDetails) {
      throw new Error('No videoDetails found in playerResponse');
    }
    
    return {
      title: videoDetails.title || 'Untitled',
      description: videoDetails.shortDescription || ''
    };
  } catch (error) {
    throw new Error(`Failed to extract video metadata: ${error}`);
  }
}

/**
 * Extract subtitle tracks from player response
 * 
 * @param playerResponse - The parsed ytInitialPlayerResponse object
 * @returns Array of available subtitle tracks
 */
export function extractSubtitleTracks(playerResponse: any): SubtitleTrack[] {
  try {
    const captionsArray = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
    
    if (!captionsArray || !Array.isArray(captionsArray)) {
      return [];
    }
    
    return captionsArray.map((caption: any): SubtitleTrack => ({
      language: caption.languageCode || 'unknown',
      name: caption.name?.simpleText || caption.name?.runs?.[0]?.text || 'Unknown',
      isAutoGenerated: caption.kind === 'asr',
      baseUrl: caption.baseUrl
    }));
  } catch (error) {
    console.warn('Failed to extract subtitle tracks:', error);
    return [];
  }
}

/**
 * Fetch subtitle XML content from URL
 * 
 * @param subtitleUrl - URL to the subtitle XML file
 * @returns Promise containing the XML content
 */
export async function fetchSubtitleXML(subtitleUrl: string): Promise<string> {
  try {
    const response = await fetch(subtitleUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return await response.text();
  } catch (error) {
    throw new Error(`Failed to fetch subtitle XML: ${error}`);
  }
}

/**
 * Validate if URL is a valid YouTube video URL
 * 
 * @param url - URL to validate
 * @returns Boolean indicating if URL is valid
 */
export function isValidYouTubeURL(url: string): boolean {
  const youtubeRegex = /^https?:\/\/(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
  return youtubeRegex.test(url);
}

/**
 * Extract video ID from YouTube URL
 * 
 * @param url - YouTube video URL
 * @returns Video ID string
 */
export function extractVideoId(url: string): string | null {
  const match = url.match(/[?&]v=([^&]+)/);
  if (match) {
    return match[1];
  }
  
  const shortMatch = url.match(/youtu\.be\/([^?&]+)/);
  if (shortMatch) {
    return shortMatch[1];
  }
  
  return null;
}
