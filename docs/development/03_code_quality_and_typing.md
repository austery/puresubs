# 代码质量与类型规范

## TypeScript 规范

### 类型定义原则

#### 1. 严格类型检查

```typescript
// tsconfig.json 配置
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noImplicitReturns": true,
    "noImplicitThis": true
  }
}
```

#### 2. 接口优于类型别名

```typescript
// ✅ 推荐：使用接口
interface YouTubeVideoData {
  title: string;
  description: string;
  availableSubtitles: SubtitleTrack[];
  subtitles?: SubtitleContent;
}

// ❌ 避免：过度使用 type
type VideoData = {
  title: string;
  // ...
};
```

#### 3. 泛型约束

```typescript
// ✅ 正确的泛型约束
interface DataExtractor<T extends VideoData> {
  extract(url: string): Promise<T>;
}

// ✅ 工厂函数泛型
function createExtractor<T extends PlatformType>(
  platform: T
): Extractor<T> {
  // 实现
}
```

### 核心类型系统

#### 视频数据类型

```typescript
interface YouTubeVideoData {
  /** 视频标题 */
  title: string;
  /** 视频描述 */
  description: string;
  /** 可用字幕轨道 */
  availableSubtitles: SubtitleTrack[];
  /** 提取的字幕内容 */
  subtitles?: SubtitleContent;
  /** 视频元数据 */
  metadata: VideoMetadata;
}

interface SubtitleTrack {
  /** 语言代码 (ISO 639-1) */
  language: string;
  /** 人类可读的语言名称 */
  name: string;
  /** 是否为自动生成 */
  isAutoGenerated: boolean;
  /** 字幕数据 URL */
  baseUrl: string;
}
```

#### 配置选项类型

```typescript
interface ExtractOptions {
  /** 首选语言列表，按优先级排序 */
  preferredLanguages?: readonly string[];
  /** 是否包含自动生成字幕 */
  includeAutoGenerated?: boolean;
  /** 是否提取字幕内容 */
  extractSubtitles?: boolean;
  /** 目标字幕语言 */
  subtitleLanguage?: string;
}
```

#### 错误处理类型

```typescript
interface ExtractorError extends Error {
  code: ErrorCode;
  context: ErrorContext;
  recoverable: boolean;
}

enum ErrorCode {
  NETWORK_ERROR = 'NETWORK_ERROR',
  PARSE_ERROR = 'PARSE_ERROR',
  NO_SUBTITLES = 'NO_SUBTITLES',
  INVALID_URL = 'INVALID_URL'
}
```

## 代码规范

### ESLint 配置

```javascript
// eslint.config.js
export default [
  {
    files: ['**/*.ts', '**/*.tsx'],
    languageOptions: {
      parser: '@typescript-eslint/parser',
      parserOptions: {
        ecmaVersion: 2024,
        sourceType: 'module'
      }
    },
    plugins: {
      '@typescript-eslint': typescriptEslint
    },
    rules: {
      // TypeScript 特定规则
      '@typescript-eslint/no-explicit-any': 'error',
      '@typescript-eslint/no-unused-vars': 'error',
      '@typescript-eslint/explicit-function-return-type': 'warn',
      
      // 代码风格
      'prefer-const': 'error',
      'no-var': 'error',
      'object-shorthand': 'error',
      
      // 最佳实践
      'no-console': ['warn', { allow: ['warn', 'error'] }],
      'no-debugger': 'error'
    }
  }
];
```

### 命名约定

#### 变量和函数命名

```typescript
// ✅ 使用驼峰命名
const videoId = 'abc123';
const extractSubtitles = async () => { /* */ };

// ✅ 布尔值使用 is/has/can 前缀
const isAutoGenerated = true;
const hasSubtitles = false;
const canExtract = true;

// ✅ 常量使用大写下划线
const MAX_RETRY_ATTEMPTS = 3;
const DEFAULT_TIMEOUT = 5000;
```

#### 类和接口命名

```typescript
// ✅ 类使用 PascalCase
class YouTubeExtractor {
  private readonly apiKey: string;
  
  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }
}

// ✅ 接口使用 PascalCase，避免 I 前缀
interface SubtitleParser {
  parse(content: string): SubtitleEntry[];
}

// ✅ 枚举使用 PascalCase
enum VideoQuality {
  HD = '720p',
  FULL_HD = '1080p',
  ULTRA_HD = '4K'
}
```

### 函数设计原则

#### 1. 单一职责

```typescript
// ✅ 单一职责函数
async function fetchVideoData(videoId: string): Promise<VideoData> {
  const response = await fetch(`/api/videos/${videoId}`);
  return response.json();
}

async function parseSubtitleXML(xmlContent: string): Promise<SubtitleEntry[]> {
  const parser = new XMLParser();
  return parser.parse(xmlContent);
}

// ❌ 职责过多的函数
async function fetchAndParseVideo(videoId: string): Promise<ParsedVideo> {
  // 获取数据 + 解析数据 + 格式转换 + 验证
}
```

#### 2. 纯函数优先

```typescript
// ✅ 纯函数，易测试
function formatDuration(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;
  
  return `${hours:02d}:${minutes:02d}:${secs:02d}`;
}

// ❌ 有副作用的函数
function logAndFormat(seconds: number): string {
  console.log(`Formatting duration: ${seconds}s`); // 副作用
  return formatDuration(seconds);
}
```

#### 3. 错误处理模式

```typescript
// ✅ 使用 Result 类型
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

async function safeExtractSubtitles(url: string): Promise<Result<SubtitleData>> {
  try {
    const data = await extractSubtitles(url);
    return { success: true, data };
  } catch (error) {
    return { 
      success: false, 
      error: error instanceof Error ? error : new Error(String(error))
    };
  }
}
```

## 测试驱动开发

### 测试文件结构

```
src/
├── parser.ts
├── parser.test.ts         # 单元测试
├── parser.integration.ts  # 集成测试
└── __tests__/
    ├── fixtures/          # 测试数据
    └── helpers/           # 测试工具
```

### 单元测试规范

```typescript
// parser.test.ts
describe('SubtitleParser', () => {
  describe('parseXML', () => {
    it('should parse valid XML subtitle content', () => {
      // Arrange
      const xmlContent = `
        <transcript>
          <text start="0" dur="2.5">Hello World</text>
        </transcript>
      `;
      
      // Act
      const result = parseSubtitleXML(xmlContent);
      
      // Assert
      expect(result).toEqual([{
        start: 0,
        end: 2.5,
        text: 'Hello World'
      }]);
    });
    
    it('should handle empty XML gracefully', () => {
      expect(() => parseSubtitleXML('')).not.toThrow();
      expect(parseSubtitleXML('')).toEqual([]);
    });
  });
});
```

### Mock 和测试替身

```typescript
// 使用 jest.mock 进行模块模拟
jest.mock('../extractor', () => ({
  fetchYouTubePageHTML: jest.fn(),
  extractPlayerResponse: jest.fn()
}));

// 类型安全的 mock
const mockFetch = fetchYouTubePageHTML as jest.MockedFunction<
  typeof fetchYouTubePageHTML
>;

beforeEach(() => {
  mockFetch.mockResolvedValue('<html>mock content</html>');
});
```

## 性能优化原则

### 1. 避免不必要的重计算

```typescript
// ✅ 使用缓存
const subtitleCache = new Map<string, SubtitleData>();

async function getCachedSubtitles(videoId: string): Promise<SubtitleData> {
  if (subtitleCache.has(videoId)) {
    return subtitleCache.get(videoId)!;
  }
  
  const data = await fetchSubtitles(videoId);
  subtitleCache.set(videoId, data);
  return data;
}
```

### 2. 懒加载和按需计算

```typescript
// ✅ 懒加载属性
class VideoProcessor {
  private _processedData?: ProcessedData;
  
  get processedData(): ProcessedData {
    if (!this._processedData) {
      this._processedData = this.computeProcessedData();
    }
    return this._processedData;
  }
}
```

### 3. 内存管理

```typescript
// ✅ 及时清理资源
class ResourceManager {
  private resources = new Set<Resource>();
  
  addResource(resource: Resource): void {
    this.resources.add(resource);
  }
  
  cleanup(): void {
    for (const resource of this.resources) {
      resource.dispose();
    }
    this.resources.clear();
  }
}
```

## 代码审查检查清单

### 类型安全

- [ ] 没有使用 `any` 类型
- [ ] 所有函数都有明确的返回类型
- [ ] 接口定义完整且准确
- [ ] 泛型约束合理

### 代码质量

- [ ] 函数职责单一，长度合理（<50行）
- [ ] 变量命名清晰，无歧义
- [ ] 没有重复代码
- [ ] 错误处理完善

### 性能考虑

- [ ] 没有不必要的重计算
- [ ] 合理使用缓存
- [ ] 内存泄漏检查
- [ ] 异步操作优化

### 测试覆盖

- [ ] 单元测试覆盖率 ≥ 95%
- [ ] 边界条件测试
- [ ] 错误场景测试
- [ ] 集成测试覆盖

## 工具配置

### Prettier 配置

```json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false
}
```

### Husky Git Hooks

```bash
# .husky/pre-commit
#!/usr/bin/env sh
npm run lint
npm run typecheck
npm run test
```

---

*"代码质量不是奢侈品，而是专业软件开发的基本要求。"*  
*— PureSubs 质量哲学*
